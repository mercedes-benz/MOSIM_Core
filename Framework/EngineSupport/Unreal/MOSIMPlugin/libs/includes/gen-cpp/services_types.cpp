/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "services_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {

int _kMDirectionValues[] = {
  MDirection::Right,
  MDirection::Left,
  MDirection::Up,
  MDirection::Down,
  MDirection::Forward,
  MDirection::Backward
};
const char* _kMDirectionNames[] = {
  "Right",
  "Left",
  "Up",
  "Down",
  "Forward",
  "Backward"
};
const std::map<int, const char*> _MDirection_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMDirectionValues, _kMDirectionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MDirection::type& val) {
  std::map<int, const char*>::const_iterator it = _MDirection_VALUES_TO_NAMES.find(val);
  if (it != _MDirection_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MDirection::type& val) {
  std::map<int, const char*>::const_iterator it = _MDirection_VALUES_TO_NAMES.find(val);
  if (it != _MDirection_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMIKOperationTypeValues[] = {
  MIKOperationType::SetPosition,
  MIKOperationType::SetRotation
};
const char* _kMIKOperationTypeNames[] = {
  "SetPosition",
  "SetRotation"
};
const std::map<int, const char*> _MIKOperationType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMIKOperationTypeValues, _kMIKOperationTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MIKOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _MIKOperationType_VALUES_TO_NAMES.find(val);
  if (it != _MIKOperationType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MIKOperationType::type& val) {
  std::map<int, const char*>::const_iterator it = _MIKOperationType_VALUES_TO_NAMES.find(val);
  if (it != _MIKOperationType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


MIKServiceResult::~MIKServiceResult() noexcept {
}


void MIKServiceResult::__set_Posture(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->Posture = val;
}

void MIKServiceResult::__set_Success(const bool val) {
  this->Success = val;
}

void MIKServiceResult::__set_Error(const std::vector<double> & val) {
  this->Error = val;
}
std::ostream& operator<<(std::ostream& out, const MIKServiceResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MIKServiceResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Posture = false;
  bool isset_Success = false;
  bool isset_Error = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Posture.read(iprot);
          isset_Posture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->Success);
          isset_Success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Error.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->Error.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readDouble(this->Error[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Posture)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Success)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Error)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MIKServiceResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MIKServiceResult");

  xfer += oprot->writeFieldBegin("Posture", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Posture.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Success", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->Success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Error", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Error.size()));
    std::vector<double> ::const_iterator _iter5;
    for (_iter5 = this->Error.begin(); _iter5 != this->Error.end(); ++_iter5)
    {
      xfer += oprot->writeDouble((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MIKServiceResult &a, MIKServiceResult &b) {
  using ::std::swap;
  swap(a.Posture, b.Posture);
  swap(a.Success, b.Success);
  swap(a.Error, b.Error);
}

MIKServiceResult::MIKServiceResult(const MIKServiceResult& other6) {
  Posture = other6.Posture;
  Success = other6.Success;
  Error = other6.Error;
}
MIKServiceResult& MIKServiceResult::operator=(const MIKServiceResult& other7) {
  Posture = other7.Posture;
  Success = other7.Success;
  Error = other7.Error;
  return *this;
}
void MIKServiceResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MIKServiceResult(";
  out << "Posture=" << to_string(Posture);
  out << ", " << "Success=" << to_string(Success);
  out << ", " << "Error=" << to_string(Error);
  out << ")";
}


MWalkPoint::~MWalkPoint() noexcept {
}


void MWalkPoint::__set_PositionConstraint(const  ::MMIStandard::MGeometryConstraint& val) {
  this->PositionConstraint = val;
}

void MWalkPoint::__set_Suitability(const double val) {
  this->Suitability = val;
}
std::ostream& operator<<(std::ostream& out, const MWalkPoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MWalkPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_PositionConstraint = false;
  bool isset_Suitability = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PositionConstraint.read(iprot);
          isset_PositionConstraint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Suitability);
          isset_Suitability = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_PositionConstraint)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Suitability)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MWalkPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MWalkPoint");

  xfer += oprot->writeFieldBegin("PositionConstraint", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->PositionConstraint.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Suitability", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Suitability);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MWalkPoint &a, MWalkPoint &b) {
  using ::std::swap;
  swap(a.PositionConstraint, b.PositionConstraint);
  swap(a.Suitability, b.Suitability);
}

MWalkPoint::MWalkPoint(const MWalkPoint& other8) {
  PositionConstraint = other8.PositionConstraint;
  Suitability = other8.Suitability;
}
MWalkPoint& MWalkPoint::operator=(const MWalkPoint& other9) {
  PositionConstraint = other9.PositionConstraint;
  Suitability = other9.Suitability;
  return *this;
}
void MWalkPoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MWalkPoint(";
  out << "PositionConstraint=" << to_string(PositionConstraint);
  out << ", " << "Suitability=" << to_string(Suitability);
  out << ")";
}


MIKProperty::~MIKProperty() noexcept {
}


void MIKProperty::__set_Values(const std::vector<double> & val) {
  this->Values = val;
}

void MIKProperty::__set_Weight(const double val) {
  this->Weight = val;
}

void MIKProperty::__set_Target(const  ::MMIStandard::MEndeffectorType::type val) {
  this->Target = val;
}

void MIKProperty::__set_OperationType(const MIKOperationType::type val) {
  this->OperationType = val;
}
std::ostream& operator<<(std::ostream& out, const MIKProperty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MIKProperty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Values = false;
  bool isset_Weight = false;
  bool isset_Target = false;
  bool isset_OperationType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Values.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->Values.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += iprot->readDouble(this->Values[_i14]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Weight);
          isset_Weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast15;
          xfer += iprot->readI32(ecast15);
          this->Target = ( ::MMIStandard::MEndeffectorType::type)ecast15;
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->OperationType = (MIKOperationType::type)ecast16;
          isset_OperationType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Weight)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_OperationType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MIKProperty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MIKProperty");

  xfer += oprot->writeFieldBegin("Values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Values.size()));
    std::vector<double> ::const_iterator _iter17;
    for (_iter17 = this->Values.begin(); _iter17 != this->Values.end(); ++_iter17)
    {
      xfer += oprot->writeDouble((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Weight", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->Target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("OperationType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->OperationType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MIKProperty &a, MIKProperty &b) {
  using ::std::swap;
  swap(a.Values, b.Values);
  swap(a.Weight, b.Weight);
  swap(a.Target, b.Target);
  swap(a.OperationType, b.OperationType);
}

MIKProperty::MIKProperty(const MIKProperty& other18) {
  Values = other18.Values;
  Weight = other18.Weight;
  Target = other18.Target;
  OperationType = other18.OperationType;
}
MIKProperty& MIKProperty::operator=(const MIKProperty& other19) {
  Values = other19.Values;
  Weight = other19.Weight;
  Target = other19.Target;
  OperationType = other19.OperationType;
  return *this;
}
void MIKProperty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MIKProperty(";
  out << "Values=" << to_string(Values);
  out << ", " << "Weight=" << to_string(Weight);
  out << ", " << "Target=" << to_string(Target);
  out << ", " << "OperationType=" << to_string(OperationType);
  out << ")";
}

} // namespace
