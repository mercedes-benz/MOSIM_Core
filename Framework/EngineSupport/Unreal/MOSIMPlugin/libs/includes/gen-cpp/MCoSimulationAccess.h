/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef MCoSimulationAccess_H
#define MCoSimulationAccess_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include <memory>
#include "cosim_types.h"
#include "MMIServiceBase.h"

namespace MMIStandard {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class MCoSimulationAccessIf : virtual public  ::MMIStandard::MMIServiceBaseIf {
 public:
  virtual ~MCoSimulationAccessIf() {}
  virtual void RegisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType) = 0;
  virtual void UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType) = 0;
  virtual void AssignInstruction( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties) = 0;
  virtual void Abort( ::MMIStandard::MBoolResponse& _return) = 0;
  virtual void AbortInstruction( ::MMIStandard::MBoolResponse& _return, const std::string& instructionID) = 0;
  virtual void AbortInstructions( ::MMIStandard::MBoolResponse& _return, const std::vector<std::string> & instructionIDs) = 0;
  virtual void GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return, const double startTime, const double endTime, const std::string& eventType) = 0;
  virtual void GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return, const int32_t fromFrame, const int32_t toFrame, const std::string& eventType) = 0;
  virtual void GetHistory(std::vector<MCoSimulationEvents> & _return, const std::string& eventType) = 0;
  virtual void GetCurrentEvents(MCoSimulationEvents& _return) = 0;
};

class MCoSimulationAccessIfFactory : virtual public  ::MMIStandard::MMIServiceBaseIfFactory {
 public:
  typedef MCoSimulationAccessIf Handler;

  virtual ~MCoSimulationAccessIfFactory() {}

  virtual MCoSimulationAccessIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler( ::MMIStandard::MMIServiceBaseIf* /* handler */) = 0;
};

class MCoSimulationAccessIfSingletonFactory : virtual public MCoSimulationAccessIfFactory {
 public:
  MCoSimulationAccessIfSingletonFactory(const ::std::shared_ptr<MCoSimulationAccessIf>& iface) : iface_(iface) {}
  virtual ~MCoSimulationAccessIfSingletonFactory() {}

  virtual MCoSimulationAccessIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler( ::MMIStandard::MMIServiceBaseIf* /* handler */) {}

 protected:
  ::std::shared_ptr<MCoSimulationAccessIf> iface_;
};

class MCoSimulationAccessNull : virtual public MCoSimulationAccessIf , virtual public  ::MMIStandard::MMIServiceBaseNull {
 public:
  virtual ~MCoSimulationAccessNull() {}
  void RegisterAtEvent( ::MMIStandard::MBoolResponse& /* _return */, const  ::MMIStandard::MIPAddress& /* clientAddress */, const std::string& /* eventType */) {
    return;
  }
  void UnregisterAtEvent( ::MMIStandard::MBoolResponse& /* _return */, const  ::MMIStandard::MIPAddress& /* clientAddress */, const std::string& /* eventType */) {
    return;
  }
  void AssignInstruction( ::MMIStandard::MBoolResponse& /* _return */, const  ::MMIStandard::MInstruction& /* instruction */, const std::map<std::string, std::string> & /* properties */) {
    return;
  }
  void Abort( ::MMIStandard::MBoolResponse& /* _return */) {
    return;
  }
  void AbortInstruction( ::MMIStandard::MBoolResponse& /* _return */, const std::string& /* instructionID */) {
    return;
  }
  void AbortInstructions( ::MMIStandard::MBoolResponse& /* _return */, const std::vector<std::string> & /* instructionIDs */) {
    return;
  }
  void GetHistoryFromTime(std::vector<MCoSimulationEvents> & /* _return */, const double /* startTime */, const double /* endTime */, const std::string& /* eventType */) {
    return;
  }
  void GetHistoryFromFrames(std::vector<MCoSimulationEvents> & /* _return */, const int32_t /* fromFrame */, const int32_t /* toFrame */, const std::string& /* eventType */) {
    return;
  }
  void GetHistory(std::vector<MCoSimulationEvents> & /* _return */, const std::string& /* eventType */) {
    return;
  }
  void GetCurrentEvents(MCoSimulationEvents& /* _return */) {
    return;
  }
};

typedef struct _MCoSimulationAccess_RegisterAtEvent_args__isset {
  _MCoSimulationAccess_RegisterAtEvent_args__isset() : clientAddress(false), eventType(false) {}
  bool clientAddress :1;
  bool eventType :1;
} _MCoSimulationAccess_RegisterAtEvent_args__isset;

class MCoSimulationAccess_RegisterAtEvent_args {
 public:

  MCoSimulationAccess_RegisterAtEvent_args(const MCoSimulationAccess_RegisterAtEvent_args&);
  MCoSimulationAccess_RegisterAtEvent_args& operator=(const MCoSimulationAccess_RegisterAtEvent_args&);
  MCoSimulationAccess_RegisterAtEvent_args() : eventType() {
  }

  virtual ~MCoSimulationAccess_RegisterAtEvent_args() noexcept;
   ::MMIStandard::MIPAddress clientAddress;
  std::string eventType;

  _MCoSimulationAccess_RegisterAtEvent_args__isset __isset;

  void __set_clientAddress(const  ::MMIStandard::MIPAddress& val);

  void __set_eventType(const std::string& val);

  bool operator == (const MCoSimulationAccess_RegisterAtEvent_args & rhs) const
  {
    if (!(clientAddress == rhs.clientAddress))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_RegisterAtEvent_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_RegisterAtEvent_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_RegisterAtEvent_pargs {
 public:


  virtual ~MCoSimulationAccess_RegisterAtEvent_pargs() noexcept;
  const  ::MMIStandard::MIPAddress* clientAddress;
  const std::string* eventType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_RegisterAtEvent_result__isset {
  _MCoSimulationAccess_RegisterAtEvent_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_RegisterAtEvent_result__isset;

class MCoSimulationAccess_RegisterAtEvent_result {
 public:

  MCoSimulationAccess_RegisterAtEvent_result(const MCoSimulationAccess_RegisterAtEvent_result&);
  MCoSimulationAccess_RegisterAtEvent_result& operator=(const MCoSimulationAccess_RegisterAtEvent_result&);
  MCoSimulationAccess_RegisterAtEvent_result() {
  }

  virtual ~MCoSimulationAccess_RegisterAtEvent_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_RegisterAtEvent_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_RegisterAtEvent_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_RegisterAtEvent_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_RegisterAtEvent_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_RegisterAtEvent_presult__isset {
  _MCoSimulationAccess_RegisterAtEvent_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_RegisterAtEvent_presult__isset;

class MCoSimulationAccess_RegisterAtEvent_presult {
 public:


  virtual ~MCoSimulationAccess_RegisterAtEvent_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_RegisterAtEvent_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_UnregisterAtEvent_args__isset {
  _MCoSimulationAccess_UnregisterAtEvent_args__isset() : clientAddress(false), eventType(false) {}
  bool clientAddress :1;
  bool eventType :1;
} _MCoSimulationAccess_UnregisterAtEvent_args__isset;

class MCoSimulationAccess_UnregisterAtEvent_args {
 public:

  MCoSimulationAccess_UnregisterAtEvent_args(const MCoSimulationAccess_UnregisterAtEvent_args&);
  MCoSimulationAccess_UnregisterAtEvent_args& operator=(const MCoSimulationAccess_UnregisterAtEvent_args&);
  MCoSimulationAccess_UnregisterAtEvent_args() : eventType() {
  }

  virtual ~MCoSimulationAccess_UnregisterAtEvent_args() noexcept;
   ::MMIStandard::MIPAddress clientAddress;
  std::string eventType;

  _MCoSimulationAccess_UnregisterAtEvent_args__isset __isset;

  void __set_clientAddress(const  ::MMIStandard::MIPAddress& val);

  void __set_eventType(const std::string& val);

  bool operator == (const MCoSimulationAccess_UnregisterAtEvent_args & rhs) const
  {
    if (!(clientAddress == rhs.clientAddress))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_UnregisterAtEvent_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_UnregisterAtEvent_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_UnregisterAtEvent_pargs {
 public:


  virtual ~MCoSimulationAccess_UnregisterAtEvent_pargs() noexcept;
  const  ::MMIStandard::MIPAddress* clientAddress;
  const std::string* eventType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_UnregisterAtEvent_result__isset {
  _MCoSimulationAccess_UnregisterAtEvent_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_UnregisterAtEvent_result__isset;

class MCoSimulationAccess_UnregisterAtEvent_result {
 public:

  MCoSimulationAccess_UnregisterAtEvent_result(const MCoSimulationAccess_UnregisterAtEvent_result&);
  MCoSimulationAccess_UnregisterAtEvent_result& operator=(const MCoSimulationAccess_UnregisterAtEvent_result&);
  MCoSimulationAccess_UnregisterAtEvent_result() {
  }

  virtual ~MCoSimulationAccess_UnregisterAtEvent_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_UnregisterAtEvent_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_UnregisterAtEvent_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_UnregisterAtEvent_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_UnregisterAtEvent_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_UnregisterAtEvent_presult__isset {
  _MCoSimulationAccess_UnregisterAtEvent_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_UnregisterAtEvent_presult__isset;

class MCoSimulationAccess_UnregisterAtEvent_presult {
 public:


  virtual ~MCoSimulationAccess_UnregisterAtEvent_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_UnregisterAtEvent_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_AssignInstruction_args__isset {
  _MCoSimulationAccess_AssignInstruction_args__isset() : instruction(false), properties(false) {}
  bool instruction :1;
  bool properties :1;
} _MCoSimulationAccess_AssignInstruction_args__isset;

class MCoSimulationAccess_AssignInstruction_args {
 public:

  MCoSimulationAccess_AssignInstruction_args(const MCoSimulationAccess_AssignInstruction_args&);
  MCoSimulationAccess_AssignInstruction_args& operator=(const MCoSimulationAccess_AssignInstruction_args&);
  MCoSimulationAccess_AssignInstruction_args() {
  }

  virtual ~MCoSimulationAccess_AssignInstruction_args() noexcept;
   ::MMIStandard::MInstruction instruction;
  std::map<std::string, std::string>  properties;

  _MCoSimulationAccess_AssignInstruction_args__isset __isset;

  void __set_instruction(const  ::MMIStandard::MInstruction& val);

  void __set_properties(const std::map<std::string, std::string> & val);

  bool operator == (const MCoSimulationAccess_AssignInstruction_args & rhs) const
  {
    if (!(instruction == rhs.instruction))
      return false;
    if (!(properties == rhs.properties))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AssignInstruction_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AssignInstruction_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_AssignInstruction_pargs {
 public:


  virtual ~MCoSimulationAccess_AssignInstruction_pargs() noexcept;
  const  ::MMIStandard::MInstruction* instruction;
  const std::map<std::string, std::string> * properties;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AssignInstruction_result__isset {
  _MCoSimulationAccess_AssignInstruction_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AssignInstruction_result__isset;

class MCoSimulationAccess_AssignInstruction_result {
 public:

  MCoSimulationAccess_AssignInstruction_result(const MCoSimulationAccess_AssignInstruction_result&);
  MCoSimulationAccess_AssignInstruction_result& operator=(const MCoSimulationAccess_AssignInstruction_result&);
  MCoSimulationAccess_AssignInstruction_result() {
  }

  virtual ~MCoSimulationAccess_AssignInstruction_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_AssignInstruction_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_AssignInstruction_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AssignInstruction_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AssignInstruction_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AssignInstruction_presult__isset {
  _MCoSimulationAccess_AssignInstruction_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AssignInstruction_presult__isset;

class MCoSimulationAccess_AssignInstruction_presult {
 public:


  virtual ~MCoSimulationAccess_AssignInstruction_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_AssignInstruction_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class MCoSimulationAccess_Abort_args {
 public:

  MCoSimulationAccess_Abort_args(const MCoSimulationAccess_Abort_args&);
  MCoSimulationAccess_Abort_args& operator=(const MCoSimulationAccess_Abort_args&);
  MCoSimulationAccess_Abort_args() {
  }

  virtual ~MCoSimulationAccess_Abort_args() noexcept;

  bool operator == (const MCoSimulationAccess_Abort_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MCoSimulationAccess_Abort_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_Abort_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_Abort_pargs {
 public:


  virtual ~MCoSimulationAccess_Abort_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_Abort_result__isset {
  _MCoSimulationAccess_Abort_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_Abort_result__isset;

class MCoSimulationAccess_Abort_result {
 public:

  MCoSimulationAccess_Abort_result(const MCoSimulationAccess_Abort_result&);
  MCoSimulationAccess_Abort_result& operator=(const MCoSimulationAccess_Abort_result&);
  MCoSimulationAccess_Abort_result() {
  }

  virtual ~MCoSimulationAccess_Abort_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_Abort_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_Abort_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_Abort_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_Abort_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_Abort_presult__isset {
  _MCoSimulationAccess_Abort_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_Abort_presult__isset;

class MCoSimulationAccess_Abort_presult {
 public:


  virtual ~MCoSimulationAccess_Abort_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_Abort_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_AbortInstruction_args__isset {
  _MCoSimulationAccess_AbortInstruction_args__isset() : instructionID(false) {}
  bool instructionID :1;
} _MCoSimulationAccess_AbortInstruction_args__isset;

class MCoSimulationAccess_AbortInstruction_args {
 public:

  MCoSimulationAccess_AbortInstruction_args(const MCoSimulationAccess_AbortInstruction_args&);
  MCoSimulationAccess_AbortInstruction_args& operator=(const MCoSimulationAccess_AbortInstruction_args&);
  MCoSimulationAccess_AbortInstruction_args() : instructionID() {
  }

  virtual ~MCoSimulationAccess_AbortInstruction_args() noexcept;
  std::string instructionID;

  _MCoSimulationAccess_AbortInstruction_args__isset __isset;

  void __set_instructionID(const std::string& val);

  bool operator == (const MCoSimulationAccess_AbortInstruction_args & rhs) const
  {
    if (!(instructionID == rhs.instructionID))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AbortInstruction_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AbortInstruction_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_AbortInstruction_pargs {
 public:


  virtual ~MCoSimulationAccess_AbortInstruction_pargs() noexcept;
  const std::string* instructionID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AbortInstruction_result__isset {
  _MCoSimulationAccess_AbortInstruction_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AbortInstruction_result__isset;

class MCoSimulationAccess_AbortInstruction_result {
 public:

  MCoSimulationAccess_AbortInstruction_result(const MCoSimulationAccess_AbortInstruction_result&);
  MCoSimulationAccess_AbortInstruction_result& operator=(const MCoSimulationAccess_AbortInstruction_result&);
  MCoSimulationAccess_AbortInstruction_result() {
  }

  virtual ~MCoSimulationAccess_AbortInstruction_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_AbortInstruction_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_AbortInstruction_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AbortInstruction_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AbortInstruction_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AbortInstruction_presult__isset {
  _MCoSimulationAccess_AbortInstruction_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AbortInstruction_presult__isset;

class MCoSimulationAccess_AbortInstruction_presult {
 public:


  virtual ~MCoSimulationAccess_AbortInstruction_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_AbortInstruction_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_AbortInstructions_args__isset {
  _MCoSimulationAccess_AbortInstructions_args__isset() : instructionIDs(false) {}
  bool instructionIDs :1;
} _MCoSimulationAccess_AbortInstructions_args__isset;

class MCoSimulationAccess_AbortInstructions_args {
 public:

  MCoSimulationAccess_AbortInstructions_args(const MCoSimulationAccess_AbortInstructions_args&);
  MCoSimulationAccess_AbortInstructions_args& operator=(const MCoSimulationAccess_AbortInstructions_args&);
  MCoSimulationAccess_AbortInstructions_args() {
  }

  virtual ~MCoSimulationAccess_AbortInstructions_args() noexcept;
  std::vector<std::string>  instructionIDs;

  _MCoSimulationAccess_AbortInstructions_args__isset __isset;

  void __set_instructionIDs(const std::vector<std::string> & val);

  bool operator == (const MCoSimulationAccess_AbortInstructions_args & rhs) const
  {
    if (!(instructionIDs == rhs.instructionIDs))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AbortInstructions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AbortInstructions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_AbortInstructions_pargs {
 public:


  virtual ~MCoSimulationAccess_AbortInstructions_pargs() noexcept;
  const std::vector<std::string> * instructionIDs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AbortInstructions_result__isset {
  _MCoSimulationAccess_AbortInstructions_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AbortInstructions_result__isset;

class MCoSimulationAccess_AbortInstructions_result {
 public:

  MCoSimulationAccess_AbortInstructions_result(const MCoSimulationAccess_AbortInstructions_result&);
  MCoSimulationAccess_AbortInstructions_result& operator=(const MCoSimulationAccess_AbortInstructions_result&);
  MCoSimulationAccess_AbortInstructions_result() {
  }

  virtual ~MCoSimulationAccess_AbortInstructions_result() noexcept;
   ::MMIStandard::MBoolResponse success;

  _MCoSimulationAccess_AbortInstructions_result__isset __isset;

  void __set_success(const  ::MMIStandard::MBoolResponse& val);

  bool operator == (const MCoSimulationAccess_AbortInstructions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_AbortInstructions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_AbortInstructions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_AbortInstructions_presult__isset {
  _MCoSimulationAccess_AbortInstructions_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_AbortInstructions_presult__isset;

class MCoSimulationAccess_AbortInstructions_presult {
 public:


  virtual ~MCoSimulationAccess_AbortInstructions_presult() noexcept;
   ::MMIStandard::MBoolResponse* success;

  _MCoSimulationAccess_AbortInstructions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_GetHistoryFromTime_args__isset {
  _MCoSimulationAccess_GetHistoryFromTime_args__isset() : startTime(false), endTime(false), eventType(false) {}
  bool startTime :1;
  bool endTime :1;
  bool eventType :1;
} _MCoSimulationAccess_GetHistoryFromTime_args__isset;

class MCoSimulationAccess_GetHistoryFromTime_args {
 public:

  MCoSimulationAccess_GetHistoryFromTime_args(const MCoSimulationAccess_GetHistoryFromTime_args&);
  MCoSimulationAccess_GetHistoryFromTime_args& operator=(const MCoSimulationAccess_GetHistoryFromTime_args&);
  MCoSimulationAccess_GetHistoryFromTime_args() : startTime(0), endTime(0), eventType() {
  }

  virtual ~MCoSimulationAccess_GetHistoryFromTime_args() noexcept;
  double startTime;
  double endTime;
  std::string eventType;

  _MCoSimulationAccess_GetHistoryFromTime_args__isset __isset;

  void __set_startTime(const double val);

  void __set_endTime(const double val);

  void __set_eventType(const std::string& val);

  bool operator == (const MCoSimulationAccess_GetHistoryFromTime_args & rhs) const
  {
    if (!(startTime == rhs.startTime))
      return false;
    if (!(endTime == rhs.endTime))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistoryFromTime_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistoryFromTime_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_GetHistoryFromTime_pargs {
 public:


  virtual ~MCoSimulationAccess_GetHistoryFromTime_pargs() noexcept;
  const double* startTime;
  const double* endTime;
  const std::string* eventType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistoryFromTime_result__isset {
  _MCoSimulationAccess_GetHistoryFromTime_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistoryFromTime_result__isset;

class MCoSimulationAccess_GetHistoryFromTime_result {
 public:

  MCoSimulationAccess_GetHistoryFromTime_result(const MCoSimulationAccess_GetHistoryFromTime_result&);
  MCoSimulationAccess_GetHistoryFromTime_result& operator=(const MCoSimulationAccess_GetHistoryFromTime_result&);
  MCoSimulationAccess_GetHistoryFromTime_result() {
  }

  virtual ~MCoSimulationAccess_GetHistoryFromTime_result() noexcept;
  std::vector<MCoSimulationEvents>  success;

  _MCoSimulationAccess_GetHistoryFromTime_result__isset __isset;

  void __set_success(const std::vector<MCoSimulationEvents> & val);

  bool operator == (const MCoSimulationAccess_GetHistoryFromTime_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistoryFromTime_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistoryFromTime_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistoryFromTime_presult__isset {
  _MCoSimulationAccess_GetHistoryFromTime_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistoryFromTime_presult__isset;

class MCoSimulationAccess_GetHistoryFromTime_presult {
 public:


  virtual ~MCoSimulationAccess_GetHistoryFromTime_presult() noexcept;
  std::vector<MCoSimulationEvents> * success;

  _MCoSimulationAccess_GetHistoryFromTime_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_GetHistoryFromFrames_args__isset {
  _MCoSimulationAccess_GetHistoryFromFrames_args__isset() : fromFrame(false), toFrame(false), eventType(false) {}
  bool fromFrame :1;
  bool toFrame :1;
  bool eventType :1;
} _MCoSimulationAccess_GetHistoryFromFrames_args__isset;

class MCoSimulationAccess_GetHistoryFromFrames_args {
 public:

  MCoSimulationAccess_GetHistoryFromFrames_args(const MCoSimulationAccess_GetHistoryFromFrames_args&);
  MCoSimulationAccess_GetHistoryFromFrames_args& operator=(const MCoSimulationAccess_GetHistoryFromFrames_args&);
  MCoSimulationAccess_GetHistoryFromFrames_args() : fromFrame(0), toFrame(0), eventType() {
  }

  virtual ~MCoSimulationAccess_GetHistoryFromFrames_args() noexcept;
  int32_t fromFrame;
  int32_t toFrame;
  std::string eventType;

  _MCoSimulationAccess_GetHistoryFromFrames_args__isset __isset;

  void __set_fromFrame(const int32_t val);

  void __set_toFrame(const int32_t val);

  void __set_eventType(const std::string& val);

  bool operator == (const MCoSimulationAccess_GetHistoryFromFrames_args & rhs) const
  {
    if (!(fromFrame == rhs.fromFrame))
      return false;
    if (!(toFrame == rhs.toFrame))
      return false;
    if (!(eventType == rhs.eventType))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistoryFromFrames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistoryFromFrames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_GetHistoryFromFrames_pargs {
 public:


  virtual ~MCoSimulationAccess_GetHistoryFromFrames_pargs() noexcept;
  const int32_t* fromFrame;
  const int32_t* toFrame;
  const std::string* eventType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistoryFromFrames_result__isset {
  _MCoSimulationAccess_GetHistoryFromFrames_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistoryFromFrames_result__isset;

class MCoSimulationAccess_GetHistoryFromFrames_result {
 public:

  MCoSimulationAccess_GetHistoryFromFrames_result(const MCoSimulationAccess_GetHistoryFromFrames_result&);
  MCoSimulationAccess_GetHistoryFromFrames_result& operator=(const MCoSimulationAccess_GetHistoryFromFrames_result&);
  MCoSimulationAccess_GetHistoryFromFrames_result() {
  }

  virtual ~MCoSimulationAccess_GetHistoryFromFrames_result() noexcept;
  std::vector<MCoSimulationEvents>  success;

  _MCoSimulationAccess_GetHistoryFromFrames_result__isset __isset;

  void __set_success(const std::vector<MCoSimulationEvents> & val);

  bool operator == (const MCoSimulationAccess_GetHistoryFromFrames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistoryFromFrames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistoryFromFrames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistoryFromFrames_presult__isset {
  _MCoSimulationAccess_GetHistoryFromFrames_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistoryFromFrames_presult__isset;

class MCoSimulationAccess_GetHistoryFromFrames_presult {
 public:


  virtual ~MCoSimulationAccess_GetHistoryFromFrames_presult() noexcept;
  std::vector<MCoSimulationEvents> * success;

  _MCoSimulationAccess_GetHistoryFromFrames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _MCoSimulationAccess_GetHistory_args__isset {
  _MCoSimulationAccess_GetHistory_args__isset() : eventType(false) {}
  bool eventType :1;
} _MCoSimulationAccess_GetHistory_args__isset;

class MCoSimulationAccess_GetHistory_args {
 public:

  MCoSimulationAccess_GetHistory_args(const MCoSimulationAccess_GetHistory_args&);
  MCoSimulationAccess_GetHistory_args& operator=(const MCoSimulationAccess_GetHistory_args&);
  MCoSimulationAccess_GetHistory_args() : eventType() {
  }

  virtual ~MCoSimulationAccess_GetHistory_args() noexcept;
  std::string eventType;

  _MCoSimulationAccess_GetHistory_args__isset __isset;

  void __set_eventType(const std::string& val);

  bool operator == (const MCoSimulationAccess_GetHistory_args & rhs) const
  {
    if (!(eventType == rhs.eventType))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistory_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistory_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_GetHistory_pargs {
 public:


  virtual ~MCoSimulationAccess_GetHistory_pargs() noexcept;
  const std::string* eventType;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistory_result__isset {
  _MCoSimulationAccess_GetHistory_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistory_result__isset;

class MCoSimulationAccess_GetHistory_result {
 public:

  MCoSimulationAccess_GetHistory_result(const MCoSimulationAccess_GetHistory_result&);
  MCoSimulationAccess_GetHistory_result& operator=(const MCoSimulationAccess_GetHistory_result&);
  MCoSimulationAccess_GetHistory_result() {
  }

  virtual ~MCoSimulationAccess_GetHistory_result() noexcept;
  std::vector<MCoSimulationEvents>  success;

  _MCoSimulationAccess_GetHistory_result__isset __isset;

  void __set_success(const std::vector<MCoSimulationEvents> & val);

  bool operator == (const MCoSimulationAccess_GetHistory_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetHistory_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetHistory_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetHistory_presult__isset {
  _MCoSimulationAccess_GetHistory_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetHistory_presult__isset;

class MCoSimulationAccess_GetHistory_presult {
 public:


  virtual ~MCoSimulationAccess_GetHistory_presult() noexcept;
  std::vector<MCoSimulationEvents> * success;

  _MCoSimulationAccess_GetHistory_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class MCoSimulationAccess_GetCurrentEvents_args {
 public:

  MCoSimulationAccess_GetCurrentEvents_args(const MCoSimulationAccess_GetCurrentEvents_args&);
  MCoSimulationAccess_GetCurrentEvents_args& operator=(const MCoSimulationAccess_GetCurrentEvents_args&);
  MCoSimulationAccess_GetCurrentEvents_args() {
  }

  virtual ~MCoSimulationAccess_GetCurrentEvents_args() noexcept;

  bool operator == (const MCoSimulationAccess_GetCurrentEvents_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetCurrentEvents_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetCurrentEvents_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class MCoSimulationAccess_GetCurrentEvents_pargs {
 public:


  virtual ~MCoSimulationAccess_GetCurrentEvents_pargs() noexcept;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetCurrentEvents_result__isset {
  _MCoSimulationAccess_GetCurrentEvents_result__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetCurrentEvents_result__isset;

class MCoSimulationAccess_GetCurrentEvents_result {
 public:

  MCoSimulationAccess_GetCurrentEvents_result(const MCoSimulationAccess_GetCurrentEvents_result&);
  MCoSimulationAccess_GetCurrentEvents_result& operator=(const MCoSimulationAccess_GetCurrentEvents_result&);
  MCoSimulationAccess_GetCurrentEvents_result() {
  }

  virtual ~MCoSimulationAccess_GetCurrentEvents_result() noexcept;
  MCoSimulationEvents success;

  _MCoSimulationAccess_GetCurrentEvents_result__isset __isset;

  void __set_success(const MCoSimulationEvents& val);

  bool operator == (const MCoSimulationAccess_GetCurrentEvents_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const MCoSimulationAccess_GetCurrentEvents_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MCoSimulationAccess_GetCurrentEvents_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _MCoSimulationAccess_GetCurrentEvents_presult__isset {
  _MCoSimulationAccess_GetCurrentEvents_presult__isset() : success(false) {}
  bool success :1;
} _MCoSimulationAccess_GetCurrentEvents_presult__isset;

class MCoSimulationAccess_GetCurrentEvents_presult {
 public:


  virtual ~MCoSimulationAccess_GetCurrentEvents_presult() noexcept;
  MCoSimulationEvents* success;

  _MCoSimulationAccess_GetCurrentEvents_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class MCoSimulationAccessClient : virtual public MCoSimulationAccessIf, public  ::MMIStandard::MMIServiceBaseClient {
 public:
  MCoSimulationAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
     ::MMIStandard::MMIServiceBaseClient(prot, prot) {}
  MCoSimulationAccessClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :     ::MMIStandard::MMIServiceBaseClient(iprot, oprot) {}
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void RegisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void send_RegisterAtEvent(const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void recv_RegisterAtEvent( ::MMIStandard::MBoolResponse& _return);
  void UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void send_UnregisterAtEvent(const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void recv_UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return);
  void AssignInstruction( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties);
  void send_AssignInstruction(const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties);
  void recv_AssignInstruction( ::MMIStandard::MBoolResponse& _return);
  void Abort( ::MMIStandard::MBoolResponse& _return);
  void send_Abort();
  void recv_Abort( ::MMIStandard::MBoolResponse& _return);
  void AbortInstruction( ::MMIStandard::MBoolResponse& _return, const std::string& instructionID);
  void send_AbortInstruction(const std::string& instructionID);
  void recv_AbortInstruction( ::MMIStandard::MBoolResponse& _return);
  void AbortInstructions( ::MMIStandard::MBoolResponse& _return, const std::vector<std::string> & instructionIDs);
  void send_AbortInstructions(const std::vector<std::string> & instructionIDs);
  void recv_AbortInstructions( ::MMIStandard::MBoolResponse& _return);
  void GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return, const double startTime, const double endTime, const std::string& eventType);
  void send_GetHistoryFromTime(const double startTime, const double endTime, const std::string& eventType);
  void recv_GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return);
  void GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return, const int32_t fromFrame, const int32_t toFrame, const std::string& eventType);
  void send_GetHistoryFromFrames(const int32_t fromFrame, const int32_t toFrame, const std::string& eventType);
  void recv_GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return);
  void GetHistory(std::vector<MCoSimulationEvents> & _return, const std::string& eventType);
  void send_GetHistory(const std::string& eventType);
  void recv_GetHistory(std::vector<MCoSimulationEvents> & _return);
  void GetCurrentEvents(MCoSimulationEvents& _return);
  void send_GetCurrentEvents();
  void recv_GetCurrentEvents(MCoSimulationEvents& _return);
};

class MCoSimulationAccessProcessor : public  ::MMIStandard::MMIServiceBaseProcessor {
 protected:
  ::std::shared_ptr<MCoSimulationAccessIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (MCoSimulationAccessProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_RegisterAtEvent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_UnregisterAtEvent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_AssignInstruction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_Abort(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_AbortInstruction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_AbortInstructions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetHistoryFromTime(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetHistoryFromFrames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetHistory(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetCurrentEvents(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  MCoSimulationAccessProcessor(::std::shared_ptr<MCoSimulationAccessIf> iface) :
     ::MMIStandard::MMIServiceBaseProcessor(iface),
    iface_(iface) {
    processMap_["RegisterAtEvent"] = &MCoSimulationAccessProcessor::process_RegisterAtEvent;
    processMap_["UnregisterAtEvent"] = &MCoSimulationAccessProcessor::process_UnregisterAtEvent;
    processMap_["AssignInstruction"] = &MCoSimulationAccessProcessor::process_AssignInstruction;
    processMap_["Abort"] = &MCoSimulationAccessProcessor::process_Abort;
    processMap_["AbortInstruction"] = &MCoSimulationAccessProcessor::process_AbortInstruction;
    processMap_["AbortInstructions"] = &MCoSimulationAccessProcessor::process_AbortInstructions;
    processMap_["GetHistoryFromTime"] = &MCoSimulationAccessProcessor::process_GetHistoryFromTime;
    processMap_["GetHistoryFromFrames"] = &MCoSimulationAccessProcessor::process_GetHistoryFromFrames;
    processMap_["GetHistory"] = &MCoSimulationAccessProcessor::process_GetHistory;
    processMap_["GetCurrentEvents"] = &MCoSimulationAccessProcessor::process_GetCurrentEvents;
  }

  virtual ~MCoSimulationAccessProcessor() {}
};

class MCoSimulationAccessProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  MCoSimulationAccessProcessorFactory(const ::std::shared_ptr< MCoSimulationAccessIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::std::shared_ptr< MCoSimulationAccessIfFactory > handlerFactory_;
};

class MCoSimulationAccessMultiface : virtual public MCoSimulationAccessIf, public  ::MMIStandard::MMIServiceBaseMultiface {
 public:
  MCoSimulationAccessMultiface(std::vector<std::shared_ptr<MCoSimulationAccessIf> >& ifaces) : ifaces_(ifaces) {
    std::vector<std::shared_ptr<MCoSimulationAccessIf> >::iterator iter;
    for (iter = ifaces.begin(); iter != ifaces.end(); ++iter) {
       ::MMIStandard::MMIServiceBaseMultiface::add(*iter);
    }
  }
  virtual ~MCoSimulationAccessMultiface() {}
 protected:
  std::vector<std::shared_ptr<MCoSimulationAccessIf> > ifaces_;
  MCoSimulationAccessMultiface() {}
  void add(::std::shared_ptr<MCoSimulationAccessIf> iface) {
     ::MMIStandard::MMIServiceBaseMultiface::add(iface);
    ifaces_.push_back(iface);
  }
 public:
  void RegisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RegisterAtEvent(_return, clientAddress, eventType);
    }
    ifaces_[i]->RegisterAtEvent(_return, clientAddress, eventType);
    return;
  }

  void UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->UnregisterAtEvent(_return, clientAddress, eventType);
    }
    ifaces_[i]->UnregisterAtEvent(_return, clientAddress, eventType);
    return;
  }

  void AssignInstruction( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->AssignInstruction(_return, instruction, properties);
    }
    ifaces_[i]->AssignInstruction(_return, instruction, properties);
    return;
  }

  void Abort( ::MMIStandard::MBoolResponse& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->Abort(_return);
    }
    ifaces_[i]->Abort(_return);
    return;
  }

  void AbortInstruction( ::MMIStandard::MBoolResponse& _return, const std::string& instructionID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->AbortInstruction(_return, instructionID);
    }
    ifaces_[i]->AbortInstruction(_return, instructionID);
    return;
  }

  void AbortInstructions( ::MMIStandard::MBoolResponse& _return, const std::vector<std::string> & instructionIDs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->AbortInstructions(_return, instructionIDs);
    }
    ifaces_[i]->AbortInstructions(_return, instructionIDs);
    return;
  }

  void GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return, const double startTime, const double endTime, const std::string& eventType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetHistoryFromTime(_return, startTime, endTime, eventType);
    }
    ifaces_[i]->GetHistoryFromTime(_return, startTime, endTime, eventType);
    return;
  }

  void GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return, const int32_t fromFrame, const int32_t toFrame, const std::string& eventType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetHistoryFromFrames(_return, fromFrame, toFrame, eventType);
    }
    ifaces_[i]->GetHistoryFromFrames(_return, fromFrame, toFrame, eventType);
    return;
  }

  void GetHistory(std::vector<MCoSimulationEvents> & _return, const std::string& eventType) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetHistory(_return, eventType);
    }
    ifaces_[i]->GetHistory(_return, eventType);
    return;
  }

  void GetCurrentEvents(MCoSimulationEvents& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetCurrentEvents(_return);
    }
    ifaces_[i]->GetCurrentEvents(_return);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class MCoSimulationAccessConcurrentClient : virtual public MCoSimulationAccessIf, public  ::MMIStandard::MMIServiceBaseConcurrentClient {
 public:
  MCoSimulationAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) :
     ::MMIStandard::MMIServiceBaseConcurrentClient(prot, prot, sync) {}
  MCoSimulationAccessConcurrentClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot, std::shared_ptr<::apache::thrift::async::TConcurrentClientSyncInfo> sync) :     ::MMIStandard::MMIServiceBaseConcurrentClient(iprot, oprot, sync) {}
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void RegisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  int32_t send_RegisterAtEvent(const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void recv_RegisterAtEvent( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  int32_t send_UnregisterAtEvent(const  ::MMIStandard::MIPAddress& clientAddress, const std::string& eventType);
  void recv_UnregisterAtEvent( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void AssignInstruction( ::MMIStandard::MBoolResponse& _return, const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties);
  int32_t send_AssignInstruction(const  ::MMIStandard::MInstruction& instruction, const std::map<std::string, std::string> & properties);
  void recv_AssignInstruction( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void Abort( ::MMIStandard::MBoolResponse& _return);
  int32_t send_Abort();
  void recv_Abort( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void AbortInstruction( ::MMIStandard::MBoolResponse& _return, const std::string& instructionID);
  int32_t send_AbortInstruction(const std::string& instructionID);
  void recv_AbortInstruction( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void AbortInstructions( ::MMIStandard::MBoolResponse& _return, const std::vector<std::string> & instructionIDs);
  int32_t send_AbortInstructions(const std::vector<std::string> & instructionIDs);
  void recv_AbortInstructions( ::MMIStandard::MBoolResponse& _return, const int32_t seqid);
  void GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return, const double startTime, const double endTime, const std::string& eventType);
  int32_t send_GetHistoryFromTime(const double startTime, const double endTime, const std::string& eventType);
  void recv_GetHistoryFromTime(std::vector<MCoSimulationEvents> & _return, const int32_t seqid);
  void GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return, const int32_t fromFrame, const int32_t toFrame, const std::string& eventType);
  int32_t send_GetHistoryFromFrames(const int32_t fromFrame, const int32_t toFrame, const std::string& eventType);
  void recv_GetHistoryFromFrames(std::vector<MCoSimulationEvents> & _return, const int32_t seqid);
  void GetHistory(std::vector<MCoSimulationEvents> & _return, const std::string& eventType);
  int32_t send_GetHistory(const std::string& eventType);
  void recv_GetHistory(std::vector<MCoSimulationEvents> & _return, const int32_t seqid);
  void GetCurrentEvents(MCoSimulationEvents& _return);
  int32_t send_GetCurrentEvents();
  void recv_GetCurrentEvents(MCoSimulationEvents& _return, const int32_t seqid);
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
