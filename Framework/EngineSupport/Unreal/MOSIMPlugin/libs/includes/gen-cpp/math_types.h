/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef math_TYPES_H
#define math_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace MMIStandard {

class MVector3;

class MVector2;

class MQuaternion;

class MVector;

class MTransform;


class MVector3 : public virtual ::apache::thrift::TBase {
 public:

  MVector3(const MVector3&);
  MVector3& operator=(const MVector3&);
  MVector3() : X(0), Y(0), Z(0) {
  }

  virtual ~MVector3() noexcept;
  double X;
  double Y;
  double Z;

  void __set_X(const double val);

  void __set_Y(const double val);

  void __set_Z(const double val);

  bool operator == (const MVector3 & rhs) const
  {
    if (!(X == rhs.X))
      return false;
    if (!(Y == rhs.Y))
      return false;
    if (!(Z == rhs.Z))
      return false;
    return true;
  }
  bool operator != (const MVector3 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MVector3 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MVector3 &a, MVector3 &b);

std::ostream& operator<<(std::ostream& out, const MVector3& obj);


class MVector2 : public virtual ::apache::thrift::TBase {
 public:

  MVector2(const MVector2&);
  MVector2& operator=(const MVector2&);
  MVector2() : X(0), Y(0) {
  }

  virtual ~MVector2() noexcept;
  double X;
  double Y;

  void __set_X(const double val);

  void __set_Y(const double val);

  bool operator == (const MVector2 & rhs) const
  {
    if (!(X == rhs.X))
      return false;
    if (!(Y == rhs.Y))
      return false;
    return true;
  }
  bool operator != (const MVector2 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MVector2 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MVector2 &a, MVector2 &b);

std::ostream& operator<<(std::ostream& out, const MVector2& obj);


class MQuaternion : public virtual ::apache::thrift::TBase {
 public:

  MQuaternion(const MQuaternion&);
  MQuaternion& operator=(const MQuaternion&);
  MQuaternion() : X(0), Y(0), Z(0), W(0) {
  }

  virtual ~MQuaternion() noexcept;
  double X;
  double Y;
  double Z;
  double W;

  void __set_X(const double val);

  void __set_Y(const double val);

  void __set_Z(const double val);

  void __set_W(const double val);

  bool operator == (const MQuaternion & rhs) const
  {
    if (!(X == rhs.X))
      return false;
    if (!(Y == rhs.Y))
      return false;
    if (!(Z == rhs.Z))
      return false;
    if (!(W == rhs.W))
      return false;
    return true;
  }
  bool operator != (const MQuaternion &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MQuaternion & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MQuaternion &a, MQuaternion &b);

std::ostream& operator<<(std::ostream& out, const MQuaternion& obj);

typedef struct _MVector__isset {
  _MVector__isset() : Values(false) {}
  bool Values :1;
} _MVector__isset;

class MVector : public virtual ::apache::thrift::TBase {
 public:

  MVector(const MVector&);
  MVector& operator=(const MVector&);
  MVector() {
  }

  virtual ~MVector() noexcept;
  std::vector<double>  Values;

  _MVector__isset __isset;

  void __set_Values(const std::vector<double> & val);

  bool operator == (const MVector & rhs) const
  {
    if (!(Values == rhs.Values))
      return false;
    return true;
  }
  bool operator != (const MVector &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MVector & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MVector &a, MVector &b);

std::ostream& operator<<(std::ostream& out, const MVector& obj);

typedef struct _MTransform__isset {
  _MTransform__isset() : Parent(false) {}
  bool Parent :1;
} _MTransform__isset;

class MTransform : public virtual ::apache::thrift::TBase {
 public:

  MTransform(const MTransform&);
  MTransform& operator=(const MTransform&);
  MTransform() : ID(), Parent() {
  }

  virtual ~MTransform() noexcept;
  std::string ID;
  MVector3 Position;
  MQuaternion Rotation;
  std::string Parent;

  _MTransform__isset __isset;

  void __set_ID(const std::string& val);

  void __set_Position(const MVector3& val);

  void __set_Rotation(const MQuaternion& val);

  void __set_Parent(const std::string& val);

  bool operator == (const MTransform & rhs) const
  {
    if (!(ID == rhs.ID))
      return false;
    if (!(Position == rhs.Position))
      return false;
    if (!(Rotation == rhs.Rotation))
      return false;
    if (__isset.Parent != rhs.__isset.Parent)
      return false;
    else if (__isset.Parent && !(Parent == rhs.Parent))
      return false;
    return true;
  }
  bool operator != (const MTransform &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MTransform &MTransform) const {		// added function body, sadam
	  int inID = stoi(MTransform.ID);
	  int thisID = stoi(this->ID);
	  if (inID < thisID)
		  return true;
  }

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MTransform &a, MTransform &b);

std::ostream& operator<<(std::ostream& out, const MTransform& obj);

} // namespace

#endif
