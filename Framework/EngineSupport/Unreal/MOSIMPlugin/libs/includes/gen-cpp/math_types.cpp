/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "math_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {


MVector3::~MVector3() noexcept {
}


void MVector3::__set_X(const double val) {
  this->X = val;
}

void MVector3::__set_Y(const double val) {
  this->Y = val;
}

void MVector3::__set_Z(const double val) {
  this->Z = val;
}
std::ostream& operator<<(std::ostream& out, const MVector3& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MVector3::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_X = false;
  bool isset_Y = false;
  bool isset_Z = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->X);
          isset_X = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Y);
          isset_Y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Z);
          isset_Z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_X)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MVector3::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MVector3");

  xfer += oprot->writeFieldBegin("X", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->X);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->Z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MVector3 &a, MVector3 &b) {
  using ::std::swap;
  swap(a.X, b.X);
  swap(a.Y, b.Y);
  swap(a.Z, b.Z);
}

MVector3::MVector3(const MVector3& other0) {
  X = other0.X;
  Y = other0.Y;
  Z = other0.Z;
}
MVector3& MVector3::operator=(const MVector3& other1) {
  X = other1.X;
  Y = other1.Y;
  Z = other1.Z;
  return *this;
}
void MVector3::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MVector3(";
  out << "X=" << to_string(X);
  out << ", " << "Y=" << to_string(Y);
  out << ", " << "Z=" << to_string(Z);
  out << ")";
}


MVector2::~MVector2() noexcept {
}


void MVector2::__set_X(const double val) {
  this->X = val;
}

void MVector2::__set_Y(const double val) {
  this->Y = val;
}
std::ostream& operator<<(std::ostream& out, const MVector2& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MVector2::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_X = false;
  bool isset_Y = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->X);
          isset_X = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Y);
          isset_Y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_X)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MVector2::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MVector2");

  xfer += oprot->writeFieldBegin("X", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->X);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MVector2 &a, MVector2 &b) {
  using ::std::swap;
  swap(a.X, b.X);
  swap(a.Y, b.Y);
}

MVector2::MVector2(const MVector2& other2) {
  X = other2.X;
  Y = other2.Y;
}
MVector2& MVector2::operator=(const MVector2& other3) {
  X = other3.X;
  Y = other3.Y;
  return *this;
}
void MVector2::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MVector2(";
  out << "X=" << to_string(X);
  out << ", " << "Y=" << to_string(Y);
  out << ")";
}


MQuaternion::~MQuaternion() noexcept {
}


void MQuaternion::__set_X(const double val) {
  this->X = val;
}

void MQuaternion::__set_Y(const double val) {
  this->Y = val;
}

void MQuaternion::__set_Z(const double val) {
  this->Z = val;
}

void MQuaternion::__set_W(const double val) {
  this->W = val;
}
std::ostream& operator<<(std::ostream& out, const MQuaternion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MQuaternion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_X = false;
  bool isset_Y = false;
  bool isset_Z = false;
  bool isset_W = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->X);
          isset_X = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Y);
          isset_Y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Z);
          isset_Z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->W);
          isset_W = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_X)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Z)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_W)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MQuaternion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MQuaternion");

  xfer += oprot->writeFieldBegin("X", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->X);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Y", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->Z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("W", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->W);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MQuaternion &a, MQuaternion &b) {
  using ::std::swap;
  swap(a.X, b.X);
  swap(a.Y, b.Y);
  swap(a.Z, b.Z);
  swap(a.W, b.W);
}

MQuaternion::MQuaternion(const MQuaternion& other4) {
  X = other4.X;
  Y = other4.Y;
  Z = other4.Z;
  W = other4.W;
}
MQuaternion& MQuaternion::operator=(const MQuaternion& other5) {
  X = other5.X;
  Y = other5.Y;
  Z = other5.Z;
  W = other5.W;
  return *this;
}
void MQuaternion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MQuaternion(";
  out << "X=" << to_string(X);
  out << ", " << "Y=" << to_string(Y);
  out << ", " << "Z=" << to_string(Z);
  out << ", " << "W=" << to_string(W);
  out << ")";
}


MVector::~MVector() noexcept {
}


void MVector::__set_Values(const std::vector<double> & val) {
  this->Values = val;
}
std::ostream& operator<<(std::ostream& out, const MVector& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MVector::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Values.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->Values.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readDouble(this->Values[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MVector::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MVector");

  xfer += oprot->writeFieldBegin("Values", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Values.size()));
    std::vector<double> ::const_iterator _iter11;
    for (_iter11 = this->Values.begin(); _iter11 != this->Values.end(); ++_iter11)
    {
      xfer += oprot->writeDouble((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MVector &a, MVector &b) {
  using ::std::swap;
  swap(a.Values, b.Values);
  swap(a.__isset, b.__isset);
}

MVector::MVector(const MVector& other12) {
  Values = other12.Values;
  __isset = other12.__isset;
}
MVector& MVector::operator=(const MVector& other13) {
  Values = other13.Values;
  __isset = other13.__isset;
  return *this;
}
void MVector::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MVector(";
  out << "Values=" << to_string(Values);
  out << ")";
}


MTransform::~MTransform() noexcept {
}


void MTransform::__set_ID(const std::string& val) {
  this->ID = val;
}

void MTransform::__set_Position(const MVector3& val) {
  this->Position = val;
}

void MTransform::__set_Rotation(const MQuaternion& val) {
  this->Rotation = val;
}

void MTransform::__set_Parent(const std::string& val) {
  this->Parent = val;
__isset.Parent = true;
}
std::ostream& operator<<(std::ostream& out, const MTransform& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTransform::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Position = false;
  bool isset_Rotation = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Position.read(iprot);
          isset_Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Rotation.read(iprot);
          isset_Rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          this->__isset.Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Position)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Rotation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MTransform::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTransform");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->Position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Rotation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->Rotation.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Parent) {
    xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Parent);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTransform &a, MTransform &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Position, b.Position);
  swap(a.Rotation, b.Rotation);
  swap(a.Parent, b.Parent);
  swap(a.__isset, b.__isset);
}

MTransform::MTransform(const MTransform& other14) {
  ID = other14.ID;
  Position = other14.Position;
  Rotation = other14.Rotation;
  Parent = other14.Parent;
  __isset = other14.__isset;
}
MTransform& MTransform::operator=(const MTransform& other15) {
  ID = other15.ID;
  Position = other15.Position;
  Rotation = other15.Rotation;
  Parent = other15.Parent;
  __isset = other15.__isset;
  return *this;
}
void MTransform::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTransform(";
  out << "ID=" << to_string(ID);
  out << ", " << "Position=" << to_string(Position);
  out << ", " << "Rotation=" << to_string(Rotation);
  out << ", " << "Parent="; (__isset.Parent ? (out << to_string(Parent)) : (out << "<null>"));
  out << ")";
}

} // namespace
