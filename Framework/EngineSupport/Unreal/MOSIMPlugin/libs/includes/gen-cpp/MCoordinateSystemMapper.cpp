/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "MCoordinateSystemMapper.h"

namespace MMIStandard {


MCoordinateSystemMapper_TransformToMMI_L_args::~MCoordinateSystemMapper_TransformToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size408;
            ::apache::thrift::protocol::TType _etype411;
            xfer += iprot->readListBegin(_etype411, _size408);
            this->coordinateSystem.resize(_size408);
            uint32_t _i412;
            for (_i412 = 0; _i412 < _size408; ++_i412)
            {
              int32_t ecast413;
              xfer += iprot->readI32(ecast413);
              this->coordinateSystem[_i412] = (MDirection::type)ecast413;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter414;
    for (_iter414 = this->coordinateSystem.begin(); _iter414 != this->coordinateSystem.end(); ++_iter414)
    {
      xfer += oprot->writeI32((int32_t)(*_iter414));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_pargs::~MCoordinateSystemMapper_TransformToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter415;
    for (_iter415 = (*(this->coordinateSystem)).begin(); _iter415 != (*(this->coordinateSystem)).end(); ++_iter415)
    {
      xfer += oprot->writeI32((int32_t)(*_iter415));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_result::~MCoordinateSystemMapper_TransformToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_L_presult::~MCoordinateSystemMapper_TransformToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_args::~MCoordinateSystemMapper_TransformToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast416;
          xfer += iprot->readI32(ecast416);
          this->firstAxis = (MDirection::type)ecast416;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast417;
          xfer += iprot->readI32(ecast417);
          this->secondAxis = (MDirection::type)ecast417;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast418;
          xfer += iprot->readI32(ecast418);
          this->thirdAxis = (MDirection::type)ecast418;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_pargs::~MCoordinateSystemMapper_TransformToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_result::~MCoordinateSystemMapper_TransformToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformToMMI_presult::~MCoordinateSystemMapper_TransformToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_args::~MCoordinateSystemMapper_TransformFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size419;
            ::apache::thrift::protocol::TType _etype422;
            xfer += iprot->readListBegin(_etype422, _size419);
            this->coordinateSystem.resize(_size419);
            uint32_t _i423;
            for (_i423 = 0; _i423 < _size419; ++_i423)
            {
              int32_t ecast424;
              xfer += iprot->readI32(ecast424);
              this->coordinateSystem[_i423] = (MDirection::type)ecast424;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter425;
    for (_iter425 = this->coordinateSystem.begin(); _iter425 != this->coordinateSystem.end(); ++_iter425)
    {
      xfer += oprot->writeI32((int32_t)(*_iter425));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_pargs::~MCoordinateSystemMapper_TransformFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter426;
    for (_iter426 = (*(this->coordinateSystem)).begin(); _iter426 != (*(this->coordinateSystem)).end(); ++_iter426)
    {
      xfer += oprot->writeI32((int32_t)(*_iter426));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_result::~MCoordinateSystemMapper_TransformFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_L_presult::~MCoordinateSystemMapper_TransformFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_args::~MCoordinateSystemMapper_TransformFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->transform.read(iprot);
          this->__isset.transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast427;
          xfer += iprot->readI32(ecast427);
          this->firstAxis = (MDirection::type)ecast427;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast428;
          xfer += iprot->readI32(ecast428);
          this->secondAxis = (MDirection::type)ecast428;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast429;
          xfer += iprot->readI32(ecast429);
          this->thirdAxis = (MDirection::type)ecast429;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_args");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_pargs::~MCoordinateSystemMapper_TransformFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_pargs");

  xfer += oprot->writeFieldBegin("transform", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->transform)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_result::~MCoordinateSystemMapper_TransformFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_TransformFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_TransformFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_TransformFromMMI_presult::~MCoordinateSystemMapper_TransformFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_TransformFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_args::~MCoordinateSystemMapper_QuaternionToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size430;
            ::apache::thrift::protocol::TType _etype433;
            xfer += iprot->readListBegin(_etype433, _size430);
            this->coordinateSystem.resize(_size430);
            uint32_t _i434;
            for (_i434 = 0; _i434 < _size430; ++_i434)
            {
              int32_t ecast435;
              xfer += iprot->readI32(ecast435);
              this->coordinateSystem[_i434] = (MDirection::type)ecast435;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter436;
    for (_iter436 = this->coordinateSystem.begin(); _iter436 != this->coordinateSystem.end(); ++_iter436)
    {
      xfer += oprot->writeI32((int32_t)(*_iter436));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_pargs::~MCoordinateSystemMapper_QuaternionToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter437;
    for (_iter437 = (*(this->coordinateSystem)).begin(); _iter437 != (*(this->coordinateSystem)).end(); ++_iter437)
    {
      xfer += oprot->writeI32((int32_t)(*_iter437));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_result::~MCoordinateSystemMapper_QuaternionToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_L_presult::~MCoordinateSystemMapper_QuaternionToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_args::~MCoordinateSystemMapper_QuaternionToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast438;
          xfer += iprot->readI32(ecast438);
          this->firstAxis = (MDirection::type)ecast438;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast439;
          xfer += iprot->readI32(ecast439);
          this->secondAxis = (MDirection::type)ecast439;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast440;
          xfer += iprot->readI32(ecast440);
          this->thirdAxis = (MDirection::type)ecast440;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_pargs::~MCoordinateSystemMapper_QuaternionToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_result::~MCoordinateSystemMapper_QuaternionToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionToMMI_presult::~MCoordinateSystemMapper_QuaternionToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_args::~MCoordinateSystemMapper_QuaternionFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size441;
            ::apache::thrift::protocol::TType _etype444;
            xfer += iprot->readListBegin(_etype444, _size441);
            this->coordinateSystem.resize(_size441);
            uint32_t _i445;
            for (_i445 = 0; _i445 < _size441; ++_i445)
            {
              int32_t ecast446;
              xfer += iprot->readI32(ecast446);
              this->coordinateSystem[_i445] = (MDirection::type)ecast446;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter447;
    for (_iter447 = this->coordinateSystem.begin(); _iter447 != this->coordinateSystem.end(); ++_iter447)
    {
      xfer += oprot->writeI32((int32_t)(*_iter447));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_pargs::~MCoordinateSystemMapper_QuaternionFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter448;
    for (_iter448 = (*(this->coordinateSystem)).begin(); _iter448 != (*(this->coordinateSystem)).end(); ++_iter448)
    {
      xfer += oprot->writeI32((int32_t)(*_iter448));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_result::~MCoordinateSystemMapper_QuaternionFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_L_presult::~MCoordinateSystemMapper_QuaternionFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_args::~MCoordinateSystemMapper_QuaternionFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast449;
          xfer += iprot->readI32(ecast449);
          this->firstAxis = (MDirection::type)ecast449;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast450;
          xfer += iprot->readI32(ecast450);
          this->secondAxis = (MDirection::type)ecast450;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast451;
          xfer += iprot->readI32(ecast451);
          this->thirdAxis = (MDirection::type)ecast451;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_pargs::~MCoordinateSystemMapper_QuaternionFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_result::~MCoordinateSystemMapper_QuaternionFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_QuaternionFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_QuaternionFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_QuaternionFromMMI_presult::~MCoordinateSystemMapper_QuaternionFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_QuaternionFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_args::~MCoordinateSystemMapper_VectorToMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size452;
            ::apache::thrift::protocol::TType _etype455;
            xfer += iprot->readListBegin(_etype455, _size452);
            this->coordinateSystem.resize(_size452);
            uint32_t _i456;
            for (_i456 = 0; _i456 < _size452; ++_i456)
            {
              int32_t ecast457;
              xfer += iprot->readI32(ecast457);
              this->coordinateSystem[_i456] = (MDirection::type)ecast457;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter458;
    for (_iter458 = this->coordinateSystem.begin(); _iter458 != this->coordinateSystem.end(); ++_iter458)
    {
      xfer += oprot->writeI32((int32_t)(*_iter458));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_pargs::~MCoordinateSystemMapper_VectorToMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter459;
    for (_iter459 = (*(this->coordinateSystem)).begin(); _iter459 != (*(this->coordinateSystem)).end(); ++_iter459)
    {
      xfer += oprot->writeI32((int32_t)(*_iter459));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_result::~MCoordinateSystemMapper_VectorToMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_L_presult::~MCoordinateSystemMapper_VectorToMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_args::~MCoordinateSystemMapper_VectorToMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast460;
          xfer += iprot->readI32(ecast460);
          this->firstAxis = (MDirection::type)ecast460;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast461;
          xfer += iprot->readI32(ecast461);
          this->secondAxis = (MDirection::type)ecast461;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast462;
          xfer += iprot->readI32(ecast462);
          this->thirdAxis = (MDirection::type)ecast462;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_pargs::~MCoordinateSystemMapper_VectorToMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_result::~MCoordinateSystemMapper_VectorToMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorToMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorToMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorToMMI_presult::~MCoordinateSystemMapper_VectorToMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorToMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_args::~MCoordinateSystemMapper_VectorFromMMI_L_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->coordinateSystem.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->coordinateSystem.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              int32_t ecast468;
              xfer += iprot->readI32(ecast468);
              this->coordinateSystem[_i467] = (MDirection::type)ecast468;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.coordinateSystem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_L_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->coordinateSystem.size()));
    std::vector<MDirection::type> ::const_iterator _iter469;
    for (_iter469 = this->coordinateSystem.begin(); _iter469 != this->coordinateSystem.end(); ++_iter469)
    {
      xfer += oprot->writeI32((int32_t)(*_iter469));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_pargs::~MCoordinateSystemMapper_VectorFromMMI_L_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("coordinateSystem", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->coordinateSystem)).size()));
    std::vector<MDirection::type> ::const_iterator _iter470;
    for (_iter470 = (*(this->coordinateSystem)).begin(); _iter470 != (*(this->coordinateSystem)).end(); ++_iter470)
    {
      xfer += oprot->writeI32((int32_t)(*_iter470));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_result::~MCoordinateSystemMapper_VectorFromMMI_L_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_L_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_L_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_L_presult::~MCoordinateSystemMapper_VectorFromMMI_L_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_L_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_args::~MCoordinateSystemMapper_VectorFromMMI_args() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->quat.read(iprot);
          this->__isset.quat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast471;
          xfer += iprot->readI32(ecast471);
          this->firstAxis = (MDirection::type)ecast471;
          this->__isset.firstAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast472;
          xfer += iprot->readI32(ecast472);
          this->secondAxis = (MDirection::type)ecast472;
          this->__isset.secondAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast473;
          xfer += iprot->readI32(ecast473);
          this->thirdAxis = (MDirection::type)ecast473;
          this->__isset.thirdAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_args");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->quat.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->firstAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->secondAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->thirdAxis);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_pargs::~MCoordinateSystemMapper_VectorFromMMI_pargs() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_pargs");

  xfer += oprot->writeFieldBegin("quat", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->quat)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("firstAxis", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->firstAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("secondAxis", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)(*(this->secondAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("thirdAxis", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)(*(this->thirdAxis)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_result::~MCoordinateSystemMapper_VectorFromMMI_result() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MCoordinateSystemMapper_VectorFromMMI_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MCoordinateSystemMapper_VectorFromMMI_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MCoordinateSystemMapper_VectorFromMMI_presult::~MCoordinateSystemMapper_VectorFromMMI_presult() noexcept {
}


uint32_t MCoordinateSystemMapper_VectorFromMMI_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void MCoordinateSystemMapperClient::TransformToMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  send_TransformToMMI_L(transform, coordinateSystem);
  recv_TransformToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_TransformToMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformToMMI_L( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformToMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_TransformToMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformToMMI(_return);
}

void MCoordinateSystemMapperClient::send_TransformToMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformToMMI( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformFromMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  send_TransformFromMMI_L(transform, coordinateSystem);
  recv_TransformFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_TransformFromMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformFromMMI_L( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::TransformFromMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_TransformFromMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_TransformFromMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_TransformFromMMI( ::MMIStandard::MTransform& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("TransformFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_TransformFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_QuaternionToMMI_L(quat, coordinateSystem);
  recv_QuaternionToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionToMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_QuaternionToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionToMMI(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionToMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionToMMI( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_QuaternionFromMMI_L(quat, coordinateSystem);
  recv_QuaternionFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionFromMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_QuaternionFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_QuaternionFromMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_QuaternionFromMMI( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QuaternionFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_QuaternionFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorToMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_VectorToMMI_L(quat, coordinateSystem);
  recv_VectorToMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_VectorToMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorToMMI_L( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorToMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorToMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorToMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_VectorToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorToMMI(_return);
}

void MCoordinateSystemMapperClient::send_VectorToMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorToMMI( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorToMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorToMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorFromMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  send_VectorFromMMI_L(quat, coordinateSystem);
  recv_VectorFromMMI_L(_return);
}

void MCoordinateSystemMapperClient::send_VectorFromMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorFromMMI_L( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorFromMMI_L") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorFromMMI_L_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI_L failed: unknown result");
}

void MCoordinateSystemMapperClient::VectorFromMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  send_VectorFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorFromMMI(_return);
}

void MCoordinateSystemMapperClient::send_VectorFromMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MCoordinateSystemMapperClient::recv_VectorFromMMI( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("VectorFromMMI") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MCoordinateSystemMapper_VectorFromMMI_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI failed: unknown result");
}

bool MCoordinateSystemMapperProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return MMIServiceBaseProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void MCoordinateSystemMapperProcessor::process_TransformToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
  }

  MCoordinateSystemMapper_TransformToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformToMMI_L", bytes);
  }

  MCoordinateSystemMapper_TransformToMMI_L_result result;
  try {
    iface_->TransformToMMI_L(result.success, args.transform, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformToMMI_L");
  }

  oprot->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformToMMI");
  }

  MCoordinateSystemMapper_TransformToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformToMMI", bytes);
  }

  MCoordinateSystemMapper_TransformToMMI_result result;
  try {
    iface_->TransformToMMI(result.success, args.transform, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformToMMI");
  }

  oprot->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
  }

  MCoordinateSystemMapper_TransformFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_TransformFromMMI_L_result result;
  try {
    iface_->TransformFromMMI_L(result.success, args.transform, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI_L");
  }

  oprot->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_TransformFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.TransformFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.TransformFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.TransformFromMMI");
  }

  MCoordinateSystemMapper_TransformFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.TransformFromMMI", bytes);
  }

  MCoordinateSystemMapper_TransformFromMMI_result result;
  try {
    iface_->TransformFromMMI(result.success, args.transform, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.TransformFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI");
  }

  oprot->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.TransformFromMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
  }

  MCoordinateSystemMapper_QuaternionToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L", bytes);
  }

  MCoordinateSystemMapper_QuaternionToMMI_L_result result;
  try {
    iface_->QuaternionToMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L");
  }

  oprot->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
  }

  MCoordinateSystemMapper_QuaternionToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionToMMI", bytes);
  }

  MCoordinateSystemMapper_QuaternionToMMI_result result;
  try {
    iface_->QuaternionToMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI");
  }

  oprot->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
  }

  MCoordinateSystemMapper_QuaternionFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_QuaternionFromMMI_L_result result;
  try {
    iface_->QuaternionFromMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L");
  }

  oprot->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_QuaternionFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.QuaternionFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.QuaternionFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
  }

  MCoordinateSystemMapper_QuaternionFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.QuaternionFromMMI", bytes);
  }

  MCoordinateSystemMapper_QuaternionFromMMI_result result;
  try {
    iface_->QuaternionFromMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI");
  }

  oprot->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.QuaternionFromMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorToMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorToMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorToMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
  }

  MCoordinateSystemMapper_VectorToMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorToMMI_L", bytes);
  }

  MCoordinateSystemMapper_VectorToMMI_L_result result;
  try {
    iface_->VectorToMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorToMMI_L");
  }

  oprot->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorToMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorToMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorToMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorToMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorToMMI");
  }

  MCoordinateSystemMapper_VectorToMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorToMMI", bytes);
  }

  MCoordinateSystemMapper_VectorToMMI_result result;
  try {
    iface_->VectorToMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorToMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorToMMI");
  }

  oprot->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorToMMI", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorFromMMI_L(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorFromMMI_L", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorFromMMI_L");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
  }

  MCoordinateSystemMapper_VectorFromMMI_L_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorFromMMI_L", bytes);
  }

  MCoordinateSystemMapper_VectorFromMMI_L_result result;
  try {
    iface_->VectorFromMMI_L(result.success, args.quat, args.coordinateSystem);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI_L");
  }

  oprot->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI_L", bytes);
  }
}

void MCoordinateSystemMapperProcessor::process_VectorFromMMI(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MCoordinateSystemMapper.VectorFromMMI", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MCoordinateSystemMapper.VectorFromMMI");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MCoordinateSystemMapper.VectorFromMMI");
  }

  MCoordinateSystemMapper_VectorFromMMI_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MCoordinateSystemMapper.VectorFromMMI", bytes);
  }

  MCoordinateSystemMapper_VectorFromMMI_result result;
  try {
    iface_->VectorFromMMI(result.success, args.quat, args.firstAxis, args.secondAxis, args.thirdAxis);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MCoordinateSystemMapper.VectorFromMMI");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI");
  }

  oprot->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MCoordinateSystemMapper.VectorFromMMI", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > MCoordinateSystemMapperProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< MCoordinateSystemMapperIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< MCoordinateSystemMapperIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new MCoordinateSystemMapperProcessor(handler));
  return processor;
}

void MCoordinateSystemMapperConcurrentClient::TransformToMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_TransformToMMI_L(transform, coordinateSystem);
  recv_TransformToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformToMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformToMMI_L( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformToMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_TransformToMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformToMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformToMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformToMMI( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformFromMMI_L( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_TransformFromMMI_L(transform, coordinateSystem);
  recv_TransformFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformFromMMI_L(const  ::MMIStandard::MTransform& transform, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_L_pargs args;
  args.transform = &transform;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformFromMMI_L( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::TransformFromMMI( ::MMIStandard::MTransform& _return, const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_TransformFromMMI(transform, firstAxis, secondAxis, thirdAxis);
  recv_TransformFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_TransformFromMMI(const  ::MMIStandard::MTransform& transform, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("TransformFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_TransformFromMMI_pargs args;
  args.transform = &transform;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_TransformFromMMI( ::MMIStandard::MTransform& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("TransformFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_TransformFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "TransformFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_QuaternionToMMI_L(quat, coordinateSystem);
  recv_QuaternionToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionToMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionToMMI_L( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_QuaternionToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionToMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionToMMI( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_QuaternionFromMMI_L(quat, coordinateSystem);
  recv_QuaternionFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionFromMMI_L(const  ::MMIStandard::MQuaternion& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionFromMMI_L( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_QuaternionFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_QuaternionFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_QuaternionFromMMI(const  ::MMIStandard::MQuaternion& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("QuaternionFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_QuaternionFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_QuaternionFromMMI( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QuaternionFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_QuaternionFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QuaternionFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorToMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_VectorToMMI_L(quat, coordinateSystem);
  recv_VectorToMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorToMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorToMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorToMMI_L( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorToMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorToMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorToMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_VectorToMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorToMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorToMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorToMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorToMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorToMMI( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorToMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorToMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorToMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorFromMMI_L( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t seqid = send_VectorFromMMI_L(quat, coordinateSystem);
  recv_VectorFromMMI_L(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorFromMMI_L(const  ::MMIStandard::MVector3& quat, const std::vector<MDirection::type> & coordinateSystem)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorFromMMI_L", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_L_pargs args;
  args.quat = &quat;
  args.coordinateSystem = &coordinateSystem;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorFromMMI_L( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorFromMMI_L") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorFromMMI_L_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI_L failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MCoordinateSystemMapperConcurrentClient::VectorFromMMI( ::MMIStandard::MVector3& _return, const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t seqid = send_VectorFromMMI(quat, firstAxis, secondAxis, thirdAxis);
  recv_VectorFromMMI(_return, seqid);
}

int32_t MCoordinateSystemMapperConcurrentClient::send_VectorFromMMI(const  ::MMIStandard::MVector3& quat, const MDirection::type firstAxis, const MDirection::type secondAxis, const MDirection::type thirdAxis)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("VectorFromMMI", ::apache::thrift::protocol::T_CALL, cseqid);

  MCoordinateSystemMapper_VectorFromMMI_pargs args;
  args.quat = &quat;
  args.firstAxis = &firstAxis;
  args.secondAxis = &secondAxis;
  args.thirdAxis = &thirdAxis;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MCoordinateSystemMapperConcurrentClient::recv_VectorFromMMI( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("VectorFromMMI") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MCoordinateSystemMapper_VectorFromMMI_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "VectorFromMMI failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

