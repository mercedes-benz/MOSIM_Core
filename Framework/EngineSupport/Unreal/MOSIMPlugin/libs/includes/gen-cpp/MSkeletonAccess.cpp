/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "MSkeletonAccess.h"

namespace MMIStandard {


MSkeletonAccess_InitializeAnthropometry_args::~MSkeletonAccess_InitializeAnthropometry_args() noexcept {
}


uint32_t MSkeletonAccess_InitializeAnthropometry_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->description.read(iprot);
          this->__isset.description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_InitializeAnthropometry_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_InitializeAnthropometry_args");

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->description.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_InitializeAnthropometry_pargs::~MSkeletonAccess_InitializeAnthropometry_pargs() noexcept {
}


uint32_t MSkeletonAccess_InitializeAnthropometry_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_InitializeAnthropometry_pargs");

  xfer += oprot->writeFieldBegin("description", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->description)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_InitializeAnthropometry_result::~MSkeletonAccess_InitializeAnthropometry_result() noexcept {
}


uint32_t MSkeletonAccess_InitializeAnthropometry_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_InitializeAnthropometry_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_InitializeAnthropometry_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_InitializeAnthropometry_presult::~MSkeletonAccess_InitializeAnthropometry_presult() noexcept {
}


uint32_t MSkeletonAccess_InitializeAnthropometry_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetAvatarDescription_args::~MSkeletonAccess_GetAvatarDescription_args() noexcept {
}


uint32_t MSkeletonAccess_GetAvatarDescription_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetAvatarDescription_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetAvatarDescription_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetAvatarDescription_pargs::~MSkeletonAccess_GetAvatarDescription_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetAvatarDescription_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetAvatarDescription_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetAvatarDescription_result::~MSkeletonAccess_GetAvatarDescription_result() noexcept {
}


uint32_t MSkeletonAccess_GetAvatarDescription_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetAvatarDescription_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetAvatarDescription_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetAvatarDescription_presult::~MSkeletonAccess_GetAvatarDescription_presult() noexcept {
}


uint32_t MSkeletonAccess_GetAvatarDescription_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetAnimatedJoints_args::~MSkeletonAccess_SetAnimatedJoints_args() noexcept {
}


uint32_t MSkeletonAccess_SetAnimatedJoints_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->joints.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->joints.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              int32_t ecast378;
              xfer += iprot->readI32(ecast378);
              this->joints[_i377] = ( ::MMIStandard::MJointType::type)ecast378;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.joints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetAnimatedJoints_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetAnimatedJoints_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->joints.size()));
    std::vector< ::MMIStandard::MJointType::type> ::const_iterator _iter379;
    for (_iter379 = this->joints.begin(); _iter379 != this->joints.end(); ++_iter379)
    {
      xfer += oprot->writeI32((int32_t)(*_iter379));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetAnimatedJoints_pargs::~MSkeletonAccess_SetAnimatedJoints_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetAnimatedJoints_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetAnimatedJoints_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->joints)).size()));
    std::vector< ::MMIStandard::MJointType::type> ::const_iterator _iter380;
    for (_iter380 = (*(this->joints)).begin(); _iter380 != (*(this->joints)).end(); ++_iter380)
    {
      xfer += oprot->writeI32((int32_t)(*_iter380));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetAnimatedJoints_result::~MSkeletonAccess_SetAnimatedJoints_result() noexcept {
}


uint32_t MSkeletonAccess_SetAnimatedJoints_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetAnimatedJoints_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetAnimatedJoints_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetAnimatedJoints_presult::~MSkeletonAccess_SetAnimatedJoints_presult() noexcept {
}


uint32_t MSkeletonAccess_SetAnimatedJoints_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetChannelData_args::~MSkeletonAccess_SetChannelData_args() noexcept {
}


uint32_t MSkeletonAccess_SetChannelData_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->values.read(iprot);
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetChannelData_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetChannelData_args");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->values.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetChannelData_pargs::~MSkeletonAccess_SetChannelData_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetChannelData_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetChannelData_pargs");

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->values)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetChannelData_result::~MSkeletonAccess_SetChannelData_result() noexcept {
}


uint32_t MSkeletonAccess_SetChannelData_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetChannelData_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetChannelData_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetChannelData_presult::~MSkeletonAccess_SetChannelData_presult() noexcept {
}


uint32_t MSkeletonAccess_SetChannelData_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetCurrentGlobalPosture_args::~MSkeletonAccess_GetCurrentGlobalPosture_args() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentGlobalPosture_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentGlobalPosture_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentGlobalPosture_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentGlobalPosture_pargs::~MSkeletonAccess_GetCurrentGlobalPosture_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentGlobalPosture_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentGlobalPosture_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentGlobalPosture_result::~MSkeletonAccess_GetCurrentGlobalPosture_result() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentGlobalPosture_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentGlobalPosture_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentGlobalPosture_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentGlobalPosture_presult::~MSkeletonAccess_GetCurrentGlobalPosture_presult() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentGlobalPosture_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetCurrentLocalPosture_args::~MSkeletonAccess_GetCurrentLocalPosture_args() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentLocalPosture_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentLocalPosture_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentLocalPosture_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentLocalPosture_pargs::~MSkeletonAccess_GetCurrentLocalPosture_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentLocalPosture_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentLocalPosture_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentLocalPosture_result::~MSkeletonAccess_GetCurrentLocalPosture_result() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentLocalPosture_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentLocalPosture_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentLocalPosture_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentLocalPosture_presult::~MSkeletonAccess_GetCurrentLocalPosture_presult() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentLocalPosture_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetCurrentPostureValues_args::~MSkeletonAccess_GetCurrentPostureValues_args() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValues_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentPostureValues_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValues_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValues_pargs::~MSkeletonAccess_GetCurrentPostureValues_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValues_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValues_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValues_result::~MSkeletonAccess_GetCurrentPostureValues_result() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValues_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentPostureValues_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValues_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValues_presult::~MSkeletonAccess_GetCurrentPostureValues_presult() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValues_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetCurrentPostureValuesPartial_args::~MSkeletonAccess_GetCurrentPostureValuesPartial_args() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->joints.clear();
            uint32_t _size381;
            ::apache::thrift::protocol::TType _etype384;
            xfer += iprot->readListBegin(_etype384, _size381);
            this->joints.resize(_size381);
            uint32_t _i385;
            for (_i385 = 0; _i385 < _size381; ++_i385)
            {
              int32_t ecast386;
              xfer += iprot->readI32(ecast386);
              this->joints[_i385] = ( ::MMIStandard::MJointType::type)ecast386;
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.joints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValuesPartial_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->joints.size()));
    std::vector< ::MMIStandard::MJointType::type> ::const_iterator _iter387;
    for (_iter387 = this->joints.begin(); _iter387 != this->joints.end(); ++_iter387)
    {
      xfer += oprot->writeI32((int32_t)(*_iter387));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValuesPartial_pargs::~MSkeletonAccess_GetCurrentPostureValuesPartial_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValuesPartial_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joints", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>((*(this->joints)).size()));
    std::vector< ::MMIStandard::MJointType::type> ::const_iterator _iter388;
    for (_iter388 = (*(this->joints)).begin(); _iter388 != (*(this->joints)).end(); ++_iter388)
    {
      xfer += oprot->writeI32((int32_t)(*_iter388));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValuesPartial_result::~MSkeletonAccess_GetCurrentPostureValuesPartial_result() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentPostureValuesPartial_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentPostureValuesPartial_presult::~MSkeletonAccess_GetCurrentPostureValuesPartial_presult() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentPostureValuesPartial_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetCurrentJointPositions_args::~MSkeletonAccess_GetCurrentJointPositions_args() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentJointPositions_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentJointPositions_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentJointPositions_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentJointPositions_pargs::~MSkeletonAccess_GetCurrentJointPositions_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentJointPositions_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentJointPositions_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentJointPositions_result::~MSkeletonAccess_GetCurrentJointPositions_result() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentJointPositions_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size389;
            ::apache::thrift::protocol::TType _etype392;
            xfer += iprot->readListBegin(_etype392, _size389);
            this->success.resize(_size389);
            uint32_t _i393;
            for (_i393 = 0; _i393 < _size389; ++_i393)
            {
              xfer += this->success[_i393].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetCurrentJointPositions_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetCurrentJointPositions_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::MMIStandard::MVector3> ::const_iterator _iter394;
      for (_iter394 = this->success.begin(); _iter394 != this->success.end(); ++_iter394)
      {
        xfer += (*_iter394).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetCurrentJointPositions_presult::~MSkeletonAccess_GetCurrentJointPositions_presult() noexcept {
}


uint32_t MSkeletonAccess_GetCurrentJointPositions_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size395;
            ::apache::thrift::protocol::TType _etype398;
            xfer += iprot->readListBegin(_etype398, _size395);
            (*(this->success)).resize(_size395);
            uint32_t _i399;
            for (_i399 = 0; _i399 < _size395; ++_i399)
            {
              xfer += (*(this->success))[_i399].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetRootPosition_args::~MSkeletonAccess_GetRootPosition_args() noexcept {
}


uint32_t MSkeletonAccess_GetRootPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetRootPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootPosition_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootPosition_pargs::~MSkeletonAccess_GetRootPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetRootPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootPosition_result::~MSkeletonAccess_GetRootPosition_result() noexcept {
}


uint32_t MSkeletonAccess_GetRootPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetRootPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootPosition_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootPosition_presult::~MSkeletonAccess_GetRootPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_GetRootPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetRootRotation_args::~MSkeletonAccess_GetRootRotation_args() noexcept {
}


uint32_t MSkeletonAccess_GetRootRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarID);
          this->__isset.avatarID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetRootRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootRotation_args");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootRotation_pargs::~MSkeletonAccess_GetRootRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetRootRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootRotation_result::~MSkeletonAccess_GetRootRotation_result() noexcept {
}


uint32_t MSkeletonAccess_GetRootRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetRootRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetRootRotation_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetRootRotation_presult::~MSkeletonAccess_GetRootRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_GetRootRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetGlobalJointPosition_args::~MSkeletonAccess_GetGlobalJointPosition_args() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast400;
          xfer += iprot->readI32(ecast400);
          this->joint = ( ::MMIStandard::MJointType::type)ecast400;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetGlobalJointPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointPosition_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointPosition_pargs::~MSkeletonAccess_GetGlobalJointPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointPosition_result::~MSkeletonAccess_GetGlobalJointPosition_result() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetGlobalJointPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointPosition_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointPosition_presult::~MSkeletonAccess_GetGlobalJointPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetGlobalJointRotation_args::~MSkeletonAccess_GetGlobalJointRotation_args() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast401;
          xfer += iprot->readI32(ecast401);
          this->joint = ( ::MMIStandard::MJointType::type)ecast401;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetGlobalJointRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointRotation_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointRotation_pargs::~MSkeletonAccess_GetGlobalJointRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointRotation_result::~MSkeletonAccess_GetGlobalJointRotation_result() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetGlobalJointRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetGlobalJointRotation_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetGlobalJointRotation_presult::~MSkeletonAccess_GetGlobalJointRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_GetGlobalJointRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetLocalJointPosition_args::~MSkeletonAccess_GetLocalJointPosition_args() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast402;
          xfer += iprot->readI32(ecast402);
          this->joint = ( ::MMIStandard::MJointType::type)ecast402;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetLocalJointPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointPosition_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointPosition_pargs::~MSkeletonAccess_GetLocalJointPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointPosition_result::~MSkeletonAccess_GetLocalJointPosition_result() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetLocalJointPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointPosition_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointPosition_presult::~MSkeletonAccess_GetLocalJointPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_GetLocalJointRotation_args::~MSkeletonAccess_GetLocalJointRotation_args() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast403;
          xfer += iprot->readI32(ecast403);
          this->joint = ( ::MMIStandard::MJointType::type)ecast403;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetLocalJointRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointRotation_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointRotation_pargs::~MSkeletonAccess_GetLocalJointRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointRotation_result::~MSkeletonAccess_GetLocalJointRotation_result() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_GetLocalJointRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_GetLocalJointRotation_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_GetLocalJointRotation_presult::~MSkeletonAccess_GetLocalJointRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_GetLocalJointRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetRootPosition_args::~MSkeletonAccess_SetRootPosition_args() noexcept {
}


uint32_t MSkeletonAccess_SetRootPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->position.read(iprot);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetRootPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootPosition_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootPosition_pargs::~MSkeletonAccess_SetRootPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetRootPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->position)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootPosition_result::~MSkeletonAccess_SetRootPosition_result() noexcept {
}


uint32_t MSkeletonAccess_SetRootPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetRootPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootPosition_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootPosition_presult::~MSkeletonAccess_SetRootPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_SetRootPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetRootRotation_args::~MSkeletonAccess_SetRootRotation_args() noexcept {
}


uint32_t MSkeletonAccess_SetRootRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rotation.read(iprot);
          this->__isset.rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetRootRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootRotation_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->rotation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootRotation_pargs::~MSkeletonAccess_SetRootRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetRootRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += (*(this->rotation)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootRotation_result::~MSkeletonAccess_SetRootRotation_result() noexcept {
}


uint32_t MSkeletonAccess_SetRootRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetRootRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetRootRotation_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetRootRotation_presult::~MSkeletonAccess_SetRootRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_SetRootRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetGlobalJointPosition_args::~MSkeletonAccess_SetGlobalJointPosition_args() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast404;
          xfer += iprot->readI32(ecast404);
          this->joint = ( ::MMIStandard::MJointType::type)ecast404;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->position.read(iprot);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetGlobalJointPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointPosition_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointPosition_pargs::~MSkeletonAccess_SetGlobalJointPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->position)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointPosition_result::~MSkeletonAccess_SetGlobalJointPosition_result() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetGlobalJointPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointPosition_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointPosition_presult::~MSkeletonAccess_SetGlobalJointPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetGlobalJointRotation_args::~MSkeletonAccess_SetGlobalJointRotation_args() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast405;
          xfer += iprot->readI32(ecast405);
          this->joint = ( ::MMIStandard::MJointType::type)ecast405;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rotation.read(iprot);
          this->__isset.rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetGlobalJointRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointRotation_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->rotation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointRotation_pargs::~MSkeletonAccess_SetGlobalJointRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->rotation)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointRotation_result::~MSkeletonAccess_SetGlobalJointRotation_result() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetGlobalJointRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetGlobalJointRotation_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetGlobalJointRotation_presult::~MSkeletonAccess_SetGlobalJointRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_SetGlobalJointRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetLocalJointPosition_args::~MSkeletonAccess_SetLocalJointPosition_args() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointPosition_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast406;
          xfer += iprot->readI32(ecast406);
          this->joint = ( ::MMIStandard::MJointType::type)ecast406;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->position.read(iprot);
          this->__isset.position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetLocalJointPosition_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointPosition_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->position.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointPosition_pargs::~MSkeletonAccess_SetLocalJointPosition_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointPosition_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointPosition_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("position", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->position)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointPosition_result::~MSkeletonAccess_SetLocalJointPosition_result() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointPosition_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetLocalJointPosition_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointPosition_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointPosition_presult::~MSkeletonAccess_SetLocalJointPosition_presult() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointPosition_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_SetLocalJointRotation_args::~MSkeletonAccess_SetLocalJointRotation_args() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointRotation_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast407;
          xfer += iprot->readI32(ecast407);
          this->joint = ( ::MMIStandard::MJointType::type)ecast407;
          this->__isset.joint = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rotation.read(iprot);
          this->__isset.rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetLocalJointRotation_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointRotation_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->joint);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->rotation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointRotation_pargs::~MSkeletonAccess_SetLocalJointRotation_pargs() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointRotation_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointRotation_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joint", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)(*(this->joint)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rotation", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->rotation)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointRotation_result::~MSkeletonAccess_SetLocalJointRotation_result() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointRotation_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_SetLocalJointRotation_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_SetLocalJointRotation_result");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_SetLocalJointRotation_presult::~MSkeletonAccess_SetLocalJointRotation_presult() noexcept {
}


uint32_t MSkeletonAccess_SetLocalJointRotation_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


MSkeletonAccess_RecomputeCurrentPostureValues_args::~MSkeletonAccess_RecomputeCurrentPostureValues_args() noexcept {
}


uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->avatarId);
          this->__isset.avatarId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_RecomputeCurrentPostureValues_args");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->avatarId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_RecomputeCurrentPostureValues_pargs::~MSkeletonAccess_RecomputeCurrentPostureValues_pargs() noexcept {
}


uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSkeletonAccess_RecomputeCurrentPostureValues_pargs");

  xfer += oprot->writeFieldBegin("avatarId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString((*(this->avatarId)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_RecomputeCurrentPostureValues_result::~MSkeletonAccess_RecomputeCurrentPostureValues_result() noexcept {
}


uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->success.read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("MSkeletonAccess_RecomputeCurrentPostureValues_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_STRUCT, 0);
    xfer += this->success.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


MSkeletonAccess_RecomputeCurrentPostureValues_presult::~MSkeletonAccess_RecomputeCurrentPostureValues_presult() noexcept {
}


uint32_t MSkeletonAccess_RecomputeCurrentPostureValues_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += (*(this->success)).read(iprot);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

void MSkeletonAccessClient::InitializeAnthropometry(const  ::MMIStandard::MAvatarDescription& description)
{
  send_InitializeAnthropometry(description);
  recv_InitializeAnthropometry();
}

void MSkeletonAccessClient::send_InitializeAnthropometry(const  ::MMIStandard::MAvatarDescription& description)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("InitializeAnthropometry", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_InitializeAnthropometry_pargs args;
  args.description = &description;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_InitializeAnthropometry()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("InitializeAnthropometry") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_InitializeAnthropometry_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::GetAvatarDescription( ::MMIStandard::MAvatarDescription& _return, const std::string& avatarID)
{
  send_GetAvatarDescription(avatarID);
  recv_GetAvatarDescription(_return);
}

void MSkeletonAccessClient::send_GetAvatarDescription(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetAvatarDescription", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetAvatarDescription_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetAvatarDescription( ::MMIStandard::MAvatarDescription& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetAvatarDescription") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetAvatarDescription_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetAvatarDescription failed: unknown result");
}

void MSkeletonAccessClient::SetAnimatedJoints(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  send_SetAnimatedJoints(avatarID, joints);
  recv_SetAnimatedJoints();
}

void MSkeletonAccessClient::send_SetAnimatedJoints(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAnimatedJoints", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetAnimatedJoints_pargs args;
  args.avatarID = &avatarID;
  args.joints = &joints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetAnimatedJoints()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAnimatedJoints") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetAnimatedJoints_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetChannelData(const  ::MMIStandard::MAvatarPostureValues& values)
{
  send_SetChannelData(values);
  recv_SetChannelData();
}

void MSkeletonAccessClient::send_SetChannelData(const  ::MMIStandard::MAvatarPostureValues& values)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetChannelData", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetChannelData_pargs args;
  args.values = &values;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetChannelData()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetChannelData") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetChannelData_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::GetCurrentGlobalPosture( ::MMIStandard::MAvatarPosture& _return, const std::string& avatarID)
{
  send_GetCurrentGlobalPosture(avatarID);
  recv_GetCurrentGlobalPosture(_return);
}

void MSkeletonAccessClient::send_GetCurrentGlobalPosture(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentGlobalPosture", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentGlobalPosture_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetCurrentGlobalPosture( ::MMIStandard::MAvatarPosture& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentGlobalPosture") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetCurrentGlobalPosture_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentGlobalPosture failed: unknown result");
}

void MSkeletonAccessClient::GetCurrentLocalPosture( ::MMIStandard::MAvatarPosture& _return, const std::string& avatarID)
{
  send_GetCurrentLocalPosture(avatarID);
  recv_GetCurrentLocalPosture(_return);
}

void MSkeletonAccessClient::send_GetCurrentLocalPosture(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentLocalPosture", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentLocalPosture_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetCurrentLocalPosture( ::MMIStandard::MAvatarPosture& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentLocalPosture") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetCurrentLocalPosture_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentLocalPosture failed: unknown result");
}

void MSkeletonAccessClient::GetCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarID)
{
  send_GetCurrentPostureValues(avatarID);
  recv_GetCurrentPostureValues(_return);
}

void MSkeletonAccessClient::send_GetCurrentPostureValues(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentPostureValues", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentPostureValues_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentPostureValues") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetCurrentPostureValues_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentPostureValues failed: unknown result");
}

void MSkeletonAccessClient::GetCurrentPostureValuesPartial( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  send_GetCurrentPostureValuesPartial(avatarID, joints);
  recv_GetCurrentPostureValuesPartial(_return);
}

void MSkeletonAccessClient::send_GetCurrentPostureValuesPartial(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentPostureValuesPartial", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentPostureValuesPartial_pargs args;
  args.avatarID = &avatarID;
  args.joints = &joints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetCurrentPostureValuesPartial( ::MMIStandard::MAvatarPostureValues& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentPostureValuesPartial") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetCurrentPostureValuesPartial_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentPostureValuesPartial failed: unknown result");
}

void MSkeletonAccessClient::GetCurrentJointPositions(std::vector< ::MMIStandard::MVector3> & _return, const std::string& avatarID)
{
  send_GetCurrentJointPositions(avatarID);
  recv_GetCurrentJointPositions(_return);
}

void MSkeletonAccessClient::send_GetCurrentJointPositions(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentJointPositions", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentJointPositions_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetCurrentJointPositions(std::vector< ::MMIStandard::MVector3> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentJointPositions") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetCurrentJointPositions_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentJointPositions failed: unknown result");
}

void MSkeletonAccessClient::GetRootPosition( ::MMIStandard::MVector3& _return, const std::string& avatarID)
{
  send_GetRootPosition(avatarID);
  recv_GetRootPosition(_return);
}

void MSkeletonAccessClient::send_GetRootPosition(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetRootPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetRootPosition_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetRootPosition( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetRootPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetRootPosition_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetRootPosition failed: unknown result");
}

void MSkeletonAccessClient::GetRootRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarID)
{
  send_GetRootRotation(avatarID);
  recv_GetRootRotation(_return);
}

void MSkeletonAccessClient::send_GetRootRotation(const std::string& avatarID)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetRootRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetRootRotation_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetRootRotation( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetRootRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetRootRotation_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetRootRotation failed: unknown result");
}

void MSkeletonAccessClient::GetGlobalJointPosition( ::MMIStandard::MVector3& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  send_GetGlobalJointPosition(avatarId, joint);
  recv_GetGlobalJointPosition(_return);
}

void MSkeletonAccessClient::send_GetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetGlobalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetGlobalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetGlobalJointPosition( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetGlobalJointPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetGlobalJointPosition_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetGlobalJointPosition failed: unknown result");
}

void MSkeletonAccessClient::GetGlobalJointRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  send_GetGlobalJointRotation(avatarId, joint);
  recv_GetGlobalJointRotation(_return);
}

void MSkeletonAccessClient::send_GetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetGlobalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetGlobalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetGlobalJointRotation( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetGlobalJointRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetGlobalJointRotation_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetGlobalJointRotation failed: unknown result");
}

void MSkeletonAccessClient::GetLocalJointPosition( ::MMIStandard::MVector3& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  send_GetLocalJointPosition(avatarId, joint);
  recv_GetLocalJointPosition(_return);
}

void MSkeletonAccessClient::send_GetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetLocalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetLocalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetLocalJointPosition( ::MMIStandard::MVector3& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetLocalJointPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetLocalJointPosition_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLocalJointPosition failed: unknown result");
}

void MSkeletonAccessClient::GetLocalJointRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  send_GetLocalJointRotation(avatarId, joint);
  recv_GetLocalJointRotation(_return);
}

void MSkeletonAccessClient::send_GetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetLocalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetLocalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_GetLocalJointRotation( ::MMIStandard::MQuaternion& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetLocalJointRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_GetLocalJointRotation_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLocalJointRotation failed: unknown result");
}

void MSkeletonAccessClient::SetRootPosition(const std::string& avatarId, const  ::MMIStandard::MVector3& position)
{
  send_SetRootPosition(avatarId, position);
  recv_SetRootPosition();
}

void MSkeletonAccessClient::send_SetRootPosition(const std::string& avatarId, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetRootPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetRootPosition_pargs args;
  args.avatarId = &avatarId;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetRootPosition()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetRootPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetRootPosition_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetRootRotation(const std::string& avatarId, const  ::MMIStandard::MQuaternion& rotation)
{
  send_SetRootRotation(avatarId, rotation);
  recv_SetRootRotation();
}

void MSkeletonAccessClient::send_SetRootRotation(const std::string& avatarId, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetRootRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetRootRotation_pargs args;
  args.avatarId = &avatarId;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetRootRotation()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetRootRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetRootRotation_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  send_SetGlobalJointPosition(avatarId, joint, position);
  recv_SetGlobalJointPosition();
}

void MSkeletonAccessClient::send_SetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetGlobalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetGlobalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetGlobalJointPosition()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetGlobalJointPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetGlobalJointPosition_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  send_SetGlobalJointRotation(avatarId, joint, rotation);
  recv_SetGlobalJointRotation();
}

void MSkeletonAccessClient::send_SetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetGlobalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetGlobalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetGlobalJointRotation()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetGlobalJointRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetGlobalJointRotation_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  send_SetLocalJointPosition(avatarId, joint, position);
  recv_SetLocalJointPosition();
}

void MSkeletonAccessClient::send_SetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetLocalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetLocalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetLocalJointPosition()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetLocalJointPosition") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetLocalJointPosition_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::SetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  send_SetLocalJointRotation(avatarId, joint, rotation);
  recv_SetLocalJointRotation();
}

void MSkeletonAccessClient::send_SetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetLocalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetLocalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_SetLocalJointRotation()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetLocalJointRotation") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_SetLocalJointRotation_presult result;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  return;
}

void MSkeletonAccessClient::RecomputeCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarId)
{
  send_RecomputeCurrentPostureValues(avatarId);
  recv_RecomputeCurrentPostureValues(_return);
}

void MSkeletonAccessClient::send_RecomputeCurrentPostureValues(const std::string& avatarId)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RecomputeCurrentPostureValues", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_RecomputeCurrentPostureValues_pargs args;
  args.avatarId = &avatarId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void MSkeletonAccessClient::recv_RecomputeCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RecomputeCurrentPostureValues") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  MSkeletonAccess_RecomputeCurrentPostureValues_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RecomputeCurrentPostureValues failed: unknown result");
}

bool MSkeletonAccessProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    return MMIServiceBaseProcessor::dispatchCall(iprot, oprot, fname, seqid, callContext);
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void MSkeletonAccessProcessor::process_InitializeAnthropometry(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.InitializeAnthropometry", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.InitializeAnthropometry");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.InitializeAnthropometry");
  }

  MSkeletonAccess_InitializeAnthropometry_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.InitializeAnthropometry", bytes);
  }

  MSkeletonAccess_InitializeAnthropometry_result result;
  try {
    iface_->InitializeAnthropometry(args.description);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.InitializeAnthropometry");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("InitializeAnthropometry", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.InitializeAnthropometry");
  }

  oprot->writeMessageBegin("InitializeAnthropometry", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.InitializeAnthropometry", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetAvatarDescription(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetAvatarDescription", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetAvatarDescription");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetAvatarDescription");
  }

  MSkeletonAccess_GetAvatarDescription_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetAvatarDescription", bytes);
  }

  MSkeletonAccess_GetAvatarDescription_result result;
  try {
    iface_->GetAvatarDescription(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetAvatarDescription");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetAvatarDescription", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetAvatarDescription");
  }

  oprot->writeMessageBegin("GetAvatarDescription", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetAvatarDescription", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetAnimatedJoints(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetAnimatedJoints", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetAnimatedJoints");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetAnimatedJoints");
  }

  MSkeletonAccess_SetAnimatedJoints_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetAnimatedJoints", bytes);
  }

  MSkeletonAccess_SetAnimatedJoints_result result;
  try {
    iface_->SetAnimatedJoints(args.avatarID, args.joints);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetAnimatedJoints");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAnimatedJoints", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetAnimatedJoints");
  }

  oprot->writeMessageBegin("SetAnimatedJoints", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetAnimatedJoints", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetChannelData(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetChannelData", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetChannelData");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetChannelData");
  }

  MSkeletonAccess_SetChannelData_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetChannelData", bytes);
  }

  MSkeletonAccess_SetChannelData_result result;
  try {
    iface_->SetChannelData(args.values);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetChannelData");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetChannelData", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetChannelData");
  }

  oprot->writeMessageBegin("SetChannelData", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetChannelData", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetCurrentGlobalPosture(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetCurrentGlobalPosture", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetCurrentGlobalPosture");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetCurrentGlobalPosture");
  }

  MSkeletonAccess_GetCurrentGlobalPosture_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetCurrentGlobalPosture", bytes);
  }

  MSkeletonAccess_GetCurrentGlobalPosture_result result;
  try {
    iface_->GetCurrentGlobalPosture(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetCurrentGlobalPosture");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentGlobalPosture", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetCurrentGlobalPosture");
  }

  oprot->writeMessageBegin("GetCurrentGlobalPosture", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetCurrentGlobalPosture", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetCurrentLocalPosture(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetCurrentLocalPosture", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetCurrentLocalPosture");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetCurrentLocalPosture");
  }

  MSkeletonAccess_GetCurrentLocalPosture_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetCurrentLocalPosture", bytes);
  }

  MSkeletonAccess_GetCurrentLocalPosture_result result;
  try {
    iface_->GetCurrentLocalPosture(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetCurrentLocalPosture");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentLocalPosture", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetCurrentLocalPosture");
  }

  oprot->writeMessageBegin("GetCurrentLocalPosture", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetCurrentLocalPosture", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetCurrentPostureValues(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetCurrentPostureValues", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetCurrentPostureValues");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetCurrentPostureValues");
  }

  MSkeletonAccess_GetCurrentPostureValues_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetCurrentPostureValues", bytes);
  }

  MSkeletonAccess_GetCurrentPostureValues_result result;
  try {
    iface_->GetCurrentPostureValues(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetCurrentPostureValues");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentPostureValues", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetCurrentPostureValues");
  }

  oprot->writeMessageBegin("GetCurrentPostureValues", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetCurrentPostureValues", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetCurrentPostureValuesPartial(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetCurrentPostureValuesPartial", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial");
  }

  MSkeletonAccess_GetCurrentPostureValuesPartial_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial", bytes);
  }

  MSkeletonAccess_GetCurrentPostureValuesPartial_result result;
  try {
    iface_->GetCurrentPostureValuesPartial(result.success, args.avatarID, args.joints);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentPostureValuesPartial", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial");
  }

  oprot->writeMessageBegin("GetCurrentPostureValuesPartial", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetCurrentPostureValuesPartial", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetCurrentJointPositions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetCurrentJointPositions", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetCurrentJointPositions");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetCurrentJointPositions");
  }

  MSkeletonAccess_GetCurrentJointPositions_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetCurrentJointPositions", bytes);
  }

  MSkeletonAccess_GetCurrentJointPositions_result result;
  try {
    iface_->GetCurrentJointPositions(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetCurrentJointPositions");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentJointPositions", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetCurrentJointPositions");
  }

  oprot->writeMessageBegin("GetCurrentJointPositions", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetCurrentJointPositions", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetRootPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetRootPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetRootPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetRootPosition");
  }

  MSkeletonAccess_GetRootPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetRootPosition", bytes);
  }

  MSkeletonAccess_GetRootPosition_result result;
  try {
    iface_->GetRootPosition(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetRootPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetRootPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetRootPosition");
  }

  oprot->writeMessageBegin("GetRootPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetRootPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetRootRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetRootRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetRootRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetRootRotation");
  }

  MSkeletonAccess_GetRootRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetRootRotation", bytes);
  }

  MSkeletonAccess_GetRootRotation_result result;
  try {
    iface_->GetRootRotation(result.success, args.avatarID);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetRootRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetRootRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetRootRotation");
  }

  oprot->writeMessageBegin("GetRootRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetRootRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetGlobalJointPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetGlobalJointPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetGlobalJointPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetGlobalJointPosition");
  }

  MSkeletonAccess_GetGlobalJointPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetGlobalJointPosition", bytes);
  }

  MSkeletonAccess_GetGlobalJointPosition_result result;
  try {
    iface_->GetGlobalJointPosition(result.success, args.avatarId, args.joint);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetGlobalJointPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetGlobalJointPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetGlobalJointPosition");
  }

  oprot->writeMessageBegin("GetGlobalJointPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetGlobalJointPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetGlobalJointRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetGlobalJointRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetGlobalJointRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetGlobalJointRotation");
  }

  MSkeletonAccess_GetGlobalJointRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetGlobalJointRotation", bytes);
  }

  MSkeletonAccess_GetGlobalJointRotation_result result;
  try {
    iface_->GetGlobalJointRotation(result.success, args.avatarId, args.joint);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetGlobalJointRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetGlobalJointRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetGlobalJointRotation");
  }

  oprot->writeMessageBegin("GetGlobalJointRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetGlobalJointRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetLocalJointPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetLocalJointPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetLocalJointPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetLocalJointPosition");
  }

  MSkeletonAccess_GetLocalJointPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetLocalJointPosition", bytes);
  }

  MSkeletonAccess_GetLocalJointPosition_result result;
  try {
    iface_->GetLocalJointPosition(result.success, args.avatarId, args.joint);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetLocalJointPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetLocalJointPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetLocalJointPosition");
  }

  oprot->writeMessageBegin("GetLocalJointPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetLocalJointPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_GetLocalJointRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.GetLocalJointRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.GetLocalJointRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.GetLocalJointRotation");
  }

  MSkeletonAccess_GetLocalJointRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.GetLocalJointRotation", bytes);
  }

  MSkeletonAccess_GetLocalJointRotation_result result;
  try {
    iface_->GetLocalJointRotation(result.success, args.avatarId, args.joint);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.GetLocalJointRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetLocalJointRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.GetLocalJointRotation");
  }

  oprot->writeMessageBegin("GetLocalJointRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.GetLocalJointRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetRootPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetRootPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetRootPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetRootPosition");
  }

  MSkeletonAccess_SetRootPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetRootPosition", bytes);
  }

  MSkeletonAccess_SetRootPosition_result result;
  try {
    iface_->SetRootPosition(args.avatarId, args.position);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetRootPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetRootPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetRootPosition");
  }

  oprot->writeMessageBegin("SetRootPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetRootPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetRootRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetRootRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetRootRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetRootRotation");
  }

  MSkeletonAccess_SetRootRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetRootRotation", bytes);
  }

  MSkeletonAccess_SetRootRotation_result result;
  try {
    iface_->SetRootRotation(args.avatarId, args.rotation);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetRootRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetRootRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetRootRotation");
  }

  oprot->writeMessageBegin("SetRootRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetRootRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetGlobalJointPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetGlobalJointPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetGlobalJointPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetGlobalJointPosition");
  }

  MSkeletonAccess_SetGlobalJointPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetGlobalJointPosition", bytes);
  }

  MSkeletonAccess_SetGlobalJointPosition_result result;
  try {
    iface_->SetGlobalJointPosition(args.avatarId, args.joint, args.position);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetGlobalJointPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetGlobalJointPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetGlobalJointPosition");
  }

  oprot->writeMessageBegin("SetGlobalJointPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetGlobalJointPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetGlobalJointRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetGlobalJointRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetGlobalJointRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetGlobalJointRotation");
  }

  MSkeletonAccess_SetGlobalJointRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetGlobalJointRotation", bytes);
  }

  MSkeletonAccess_SetGlobalJointRotation_result result;
  try {
    iface_->SetGlobalJointRotation(args.avatarId, args.joint, args.rotation);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetGlobalJointRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetGlobalJointRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetGlobalJointRotation");
  }

  oprot->writeMessageBegin("SetGlobalJointRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetGlobalJointRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetLocalJointPosition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetLocalJointPosition", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetLocalJointPosition");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetLocalJointPosition");
  }

  MSkeletonAccess_SetLocalJointPosition_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetLocalJointPosition", bytes);
  }

  MSkeletonAccess_SetLocalJointPosition_result result;
  try {
    iface_->SetLocalJointPosition(args.avatarId, args.joint, args.position);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetLocalJointPosition");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetLocalJointPosition", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetLocalJointPosition");
  }

  oprot->writeMessageBegin("SetLocalJointPosition", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetLocalJointPosition", bytes);
  }
}

void MSkeletonAccessProcessor::process_SetLocalJointRotation(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.SetLocalJointRotation", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.SetLocalJointRotation");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.SetLocalJointRotation");
  }

  MSkeletonAccess_SetLocalJointRotation_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.SetLocalJointRotation", bytes);
  }

  MSkeletonAccess_SetLocalJointRotation_result result;
  try {
    iface_->SetLocalJointRotation(args.avatarId, args.joint, args.rotation);
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.SetLocalJointRotation");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetLocalJointRotation", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.SetLocalJointRotation");
  }

  oprot->writeMessageBegin("SetLocalJointRotation", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.SetLocalJointRotation", bytes);
  }
}

void MSkeletonAccessProcessor::process_RecomputeCurrentPostureValues(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("MSkeletonAccess.RecomputeCurrentPostureValues", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "MSkeletonAccess.RecomputeCurrentPostureValues");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "MSkeletonAccess.RecomputeCurrentPostureValues");
  }

  MSkeletonAccess_RecomputeCurrentPostureValues_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "MSkeletonAccess.RecomputeCurrentPostureValues", bytes);
  }

  MSkeletonAccess_RecomputeCurrentPostureValues_result result;
  try {
    iface_->RecomputeCurrentPostureValues(result.success, args.avatarId);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "MSkeletonAccess.RecomputeCurrentPostureValues");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RecomputeCurrentPostureValues", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "MSkeletonAccess.RecomputeCurrentPostureValues");
  }

  oprot->writeMessageBegin("RecomputeCurrentPostureValues", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "MSkeletonAccess.RecomputeCurrentPostureValues", bytes);
  }
}

::std::shared_ptr< ::apache::thrift::TProcessor > MSkeletonAccessProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< MSkeletonAccessIfFactory > cleanup(handlerFactory_);
  ::std::shared_ptr< MSkeletonAccessIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::std::shared_ptr< ::apache::thrift::TProcessor > processor(new MSkeletonAccessProcessor(handler));
  return processor;
}

void MSkeletonAccessConcurrentClient::InitializeAnthropometry(const  ::MMIStandard::MAvatarDescription& description)
{
  int32_t seqid = send_InitializeAnthropometry(description);
  recv_InitializeAnthropometry(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_InitializeAnthropometry(const  ::MMIStandard::MAvatarDescription& description)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("InitializeAnthropometry", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_InitializeAnthropometry_pargs args;
  args.description = &description;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_InitializeAnthropometry(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("InitializeAnthropometry") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_InitializeAnthropometry_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetAvatarDescription( ::MMIStandard::MAvatarDescription& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetAvatarDescription(avatarID);
  recv_GetAvatarDescription(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetAvatarDescription(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetAvatarDescription", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetAvatarDescription_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetAvatarDescription( ::MMIStandard::MAvatarDescription& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetAvatarDescription") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetAvatarDescription_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetAvatarDescription failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetAnimatedJoints(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t seqid = send_SetAnimatedJoints(avatarID, joints);
  recv_SetAnimatedJoints(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetAnimatedJoints(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetAnimatedJoints", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetAnimatedJoints_pargs args;
  args.avatarID = &avatarID;
  args.joints = &joints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetAnimatedJoints(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAnimatedJoints") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetAnimatedJoints_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetChannelData(const  ::MMIStandard::MAvatarPostureValues& values)
{
  int32_t seqid = send_SetChannelData(values);
  recv_SetChannelData(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetChannelData(const  ::MMIStandard::MAvatarPostureValues& values)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetChannelData", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetChannelData_pargs args;
  args.values = &values;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetChannelData(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetChannelData") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetChannelData_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetCurrentGlobalPosture( ::MMIStandard::MAvatarPosture& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetCurrentGlobalPosture(avatarID);
  recv_GetCurrentGlobalPosture(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetCurrentGlobalPosture(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetCurrentGlobalPosture", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentGlobalPosture_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetCurrentGlobalPosture( ::MMIStandard::MAvatarPosture& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentGlobalPosture") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetCurrentGlobalPosture_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentGlobalPosture failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetCurrentLocalPosture( ::MMIStandard::MAvatarPosture& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetCurrentLocalPosture(avatarID);
  recv_GetCurrentLocalPosture(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetCurrentLocalPosture(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetCurrentLocalPosture", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentLocalPosture_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetCurrentLocalPosture( ::MMIStandard::MAvatarPosture& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentLocalPosture") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetCurrentLocalPosture_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentLocalPosture failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetCurrentPostureValues(avatarID);
  recv_GetCurrentPostureValues(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetCurrentPostureValues(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetCurrentPostureValues", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentPostureValues_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentPostureValues") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetCurrentPostureValues_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentPostureValues failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetCurrentPostureValuesPartial( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t seqid = send_GetCurrentPostureValuesPartial(avatarID, joints);
  recv_GetCurrentPostureValuesPartial(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetCurrentPostureValuesPartial(const std::string& avatarID, const std::vector< ::MMIStandard::MJointType::type> & joints)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetCurrentPostureValuesPartial", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentPostureValuesPartial_pargs args;
  args.avatarID = &avatarID;
  args.joints = &joints;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetCurrentPostureValuesPartial( ::MMIStandard::MAvatarPostureValues& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentPostureValuesPartial") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetCurrentPostureValuesPartial_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentPostureValuesPartial failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetCurrentJointPositions(std::vector< ::MMIStandard::MVector3> & _return, const std::string& avatarID)
{
  int32_t seqid = send_GetCurrentJointPositions(avatarID);
  recv_GetCurrentJointPositions(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetCurrentJointPositions(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetCurrentJointPositions", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetCurrentJointPositions_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetCurrentJointPositions(std::vector< ::MMIStandard::MVector3> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentJointPositions") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetCurrentJointPositions_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentJointPositions failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetRootPosition( ::MMIStandard::MVector3& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetRootPosition(avatarID);
  recv_GetRootPosition(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetRootPosition(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetRootPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetRootPosition_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetRootPosition( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetRootPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetRootPosition_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetRootPosition failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetRootRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarID)
{
  int32_t seqid = send_GetRootRotation(avatarID);
  recv_GetRootRotation(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetRootRotation(const std::string& avatarID)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetRootRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetRootRotation_pargs args;
  args.avatarID = &avatarID;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetRootRotation( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetRootRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetRootRotation_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetRootRotation failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetGlobalJointPosition( ::MMIStandard::MVector3& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t seqid = send_GetGlobalJointPosition(avatarId, joint);
  recv_GetGlobalJointPosition(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetGlobalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetGlobalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetGlobalJointPosition( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetGlobalJointPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetGlobalJointPosition_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetGlobalJointPosition failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetGlobalJointRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t seqid = send_GetGlobalJointRotation(avatarId, joint);
  recv_GetGlobalJointRotation(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetGlobalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetGlobalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetGlobalJointRotation( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetGlobalJointRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetGlobalJointRotation_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetGlobalJointRotation failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetLocalJointPosition( ::MMIStandard::MVector3& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t seqid = send_GetLocalJointPosition(avatarId, joint);
  recv_GetLocalJointPosition(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetLocalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetLocalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetLocalJointPosition( ::MMIStandard::MVector3& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetLocalJointPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetLocalJointPosition_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLocalJointPosition failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::GetLocalJointRotation( ::MMIStandard::MQuaternion& _return, const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t seqid = send_GetLocalJointRotation(avatarId, joint);
  recv_GetLocalJointRotation(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_GetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("GetLocalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_GetLocalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_GetLocalJointRotation( ::MMIStandard::MQuaternion& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetLocalJointRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_GetLocalJointRotation_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLocalJointRotation failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetRootPosition(const std::string& avatarId, const  ::MMIStandard::MVector3& position)
{
  int32_t seqid = send_SetRootPosition(avatarId, position);
  recv_SetRootPosition(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetRootPosition(const std::string& avatarId, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetRootPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetRootPosition_pargs args;
  args.avatarId = &avatarId;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetRootPosition(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetRootPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetRootPosition_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetRootRotation(const std::string& avatarId, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t seqid = send_SetRootRotation(avatarId, rotation);
  recv_SetRootRotation(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetRootRotation(const std::string& avatarId, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetRootRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetRootRotation_pargs args;
  args.avatarId = &avatarId;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetRootRotation(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetRootRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetRootRotation_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t seqid = send_SetGlobalJointPosition(avatarId, joint, position);
  recv_SetGlobalJointPosition(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetGlobalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetGlobalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetGlobalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetGlobalJointPosition(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetGlobalJointPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetGlobalJointPosition_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t seqid = send_SetGlobalJointRotation(avatarId, joint, rotation);
  recv_SetGlobalJointRotation(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetGlobalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetGlobalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetGlobalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetGlobalJointRotation(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetGlobalJointRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetGlobalJointRotation_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t seqid = send_SetLocalJointPosition(avatarId, joint, position);
  recv_SetLocalJointPosition(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetLocalJointPosition(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MVector3& position)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetLocalJointPosition", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetLocalJointPosition_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.position = &position;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetLocalJointPosition(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetLocalJointPosition") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetLocalJointPosition_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::SetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t seqid = send_SetLocalJointRotation(avatarId, joint, rotation);
  recv_SetLocalJointRotation(seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_SetLocalJointRotation(const std::string& avatarId, const  ::MMIStandard::MJointType::type joint, const  ::MMIStandard::MQuaternion& rotation)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("SetLocalJointRotation", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_SetLocalJointRotation_pargs args;
  args.avatarId = &avatarId;
  args.joint = &joint;
  args.rotation = &rotation;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_SetLocalJointRotation(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetLocalJointRotation") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_SetLocalJointRotation_presult result;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      sentry.commit();
      return;
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

void MSkeletonAccessConcurrentClient::RecomputeCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const std::string& avatarId)
{
  int32_t seqid = send_RecomputeCurrentPostureValues(avatarId);
  recv_RecomputeCurrentPostureValues(_return, seqid);
}

int32_t MSkeletonAccessConcurrentClient::send_RecomputeCurrentPostureValues(const std::string& avatarId)
{
  int32_t cseqid = this->sync_->generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(this->sync_.get());
  oprot_->writeMessageBegin("RecomputeCurrentPostureValues", ::apache::thrift::protocol::T_CALL, cseqid);

  MSkeletonAccess_RecomputeCurrentPostureValues_pargs args;
  args.avatarId = &avatarId;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void MSkeletonAccessConcurrentClient::recv_RecomputeCurrentPostureValues( ::MMIStandard::MAvatarPostureValues& _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(this->sync_.get(), seqid);

  while(true) {
    if(!this->sync_->getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RecomputeCurrentPostureValues") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      MSkeletonAccess_RecomputeCurrentPostureValues_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RecomputeCurrentPostureValues failed: unknown result");
    }
    // seqid != rseqid
    this->sync_->updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_->waitForWork(seqid);
  } // end while(true)
}

} // namespace

