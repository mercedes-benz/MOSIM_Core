/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "scene_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {

int _kMDrawingCallTypeValues[] = {
  MDrawingCallType::DrawLine2D,
  MDrawingCallType::DrawLine3D,
  MDrawingCallType::DrawPoint2D,
  MDrawingCallType::DrawPoint3D,
  MDrawingCallType::DrawText,
  MDrawingCallType::Custom
};
const char* _kMDrawingCallTypeNames[] = {
  "DrawLine2D",
  "DrawLine3D",
  "DrawPoint2D",
  "DrawPoint3D",
  "DrawText",
  "Custom"
};
const std::map<int, const char*> _MDrawingCallType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kMDrawingCallTypeValues, _kMDrawingCallTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MDrawingCallType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDrawingCallType_VALUES_TO_NAMES.find(val);
  if (it != _MDrawingCallType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MDrawingCallType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDrawingCallType_VALUES_TO_NAMES.find(val);
  if (it != _MDrawingCallType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMPhysicsInteractionTypeValues[] = {
  MPhysicsInteractionType::AddForce,
  MPhysicsInteractionType::AddTorque,
  MPhysicsInteractionType::ChangeVelocity,
  MPhysicsInteractionType::ChangeAngularVelocity,
  MPhysicsInteractionType::ChangeMass,
  MPhysicsInteractionType::ChangeCenterOfMass,
  MPhysicsInteractionType::ChangeInertia
};
const char* _kMPhysicsInteractionTypeNames[] = {
  "AddForce",
  "AddTorque",
  "ChangeVelocity",
  "ChangeAngularVelocity",
  "ChangeMass",
  "ChangeCenterOfMass",
  "ChangeInertia"
};
const std::map<int, const char*> _MPhysicsInteractionType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMPhysicsInteractionTypeValues, _kMPhysicsInteractionTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MPhysicsInteractionType::type& val) {
  std::map<int, const char*>::const_iterator it = _MPhysicsInteractionType_VALUES_TO_NAMES.find(val);
  if (it != _MPhysicsInteractionType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MPhysicsInteractionType::type& val) {
  std::map<int, const char*>::const_iterator it = _MPhysicsInteractionType_VALUES_TO_NAMES.find(val);
  if (it != _MPhysicsInteractionType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMColliderTypeValues[] = {
  MColliderType::Box,
  MColliderType::Sphere,
  MColliderType::Capsule,
  MColliderType::Cone,
  MColliderType::Cylinder,
  MColliderType::Mesh,
  MColliderType::Custom
};
const char* _kMColliderTypeNames[] = {
  "Box",
  "Sphere",
  "Capsule",
  "Cone",
  "Cylinder",
  "Mesh",
  "Custom"
};
const std::map<int, const char*> _MColliderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kMColliderTypeValues, _kMColliderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MColliderType::type& val) {
  std::map<int, const char*>::const_iterator it = _MColliderType_VALUES_TO_NAMES.find(val);
  if (it != _MColliderType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MColliderType::type& val) {
  std::map<int, const char*>::const_iterator it = _MColliderType_VALUES_TO_NAMES.find(val);
  if (it != _MColliderType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


MAttachment::~MAttachment() noexcept {
}


void MAttachment::__set_Parent(const std::string& val) {
  this->Parent = val;
}

void MAttachment::__set_Child(const std::string& val) {
  this->Child = val;
}

void MAttachment::__set_Type(const std::string& val) {
  this->Type = val;
__isset.Type = true;
}
std::ostream& operator<<(std::ostream& out, const MAttachment& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAttachment::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Parent = false;
  bool isset_Child = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          isset_Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Child);
          isset_Child = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Type);
          this->__isset.Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Child)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAttachment::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAttachment");

  xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Child", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Child);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Type) {
    xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->Type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAttachment &a, MAttachment &b) {
  using ::std::swap;
  swap(a.Parent, b.Parent);
  swap(a.Child, b.Child);
  swap(a.Type, b.Type);
  swap(a.__isset, b.__isset);
}

MAttachment::MAttachment(const MAttachment& other0) {
  Parent = other0.Parent;
  Child = other0.Child;
  Type = other0.Type;
  __isset = other0.__isset;
}
MAttachment& MAttachment::operator=(const MAttachment& other1) {
  Parent = other1.Parent;
  Child = other1.Child;
  Type = other1.Type;
  __isset = other1.__isset;
  return *this;
}
void MAttachment::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAttachment(";
  out << "Parent=" << to_string(Parent);
  out << ", " << "Child=" << to_string(Child);
  out << ", " << "Type="; (__isset.Type ? (out << to_string(Type)) : (out << "<null>"));
  out << ")";
}


MAttachmentManipulation::~MAttachmentManipulation() noexcept {
}


void MAttachmentManipulation::__set_Parent(const std::string& val) {
  this->Parent = val;
}

void MAttachmentManipulation::__set_Child(const std::string& val) {
  this->Child = val;
}

void MAttachmentManipulation::__set_AddRemove(const bool val) {
  this->AddRemove = val;
}

void MAttachmentManipulation::__set_Type(const std::string& val) {
  this->Type = val;
__isset.Type = true;
}
std::ostream& operator<<(std::ostream& out, const MAttachmentManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAttachmentManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Parent = false;
  bool isset_Child = false;
  bool isset_AddRemove = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          isset_Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Child);
          isset_Child = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AddRemove);
          isset_AddRemove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Type);
          this->__isset.Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Parent)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Child)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_AddRemove)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAttachmentManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAttachmentManipulation");

  xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Child", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Child);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AddRemove", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->AddRemove);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Type) {
    xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Type);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAttachmentManipulation &a, MAttachmentManipulation &b) {
  using ::std::swap;
  swap(a.Parent, b.Parent);
  swap(a.Child, b.Child);
  swap(a.AddRemove, b.AddRemove);
  swap(a.Type, b.Type);
  swap(a.__isset, b.__isset);
}

MAttachmentManipulation::MAttachmentManipulation(const MAttachmentManipulation& other2) {
  Parent = other2.Parent;
  Child = other2.Child;
  AddRemove = other2.AddRemove;
  Type = other2.Type;
  __isset = other2.__isset;
}
MAttachmentManipulation& MAttachmentManipulation::operator=(const MAttachmentManipulation& other3) {
  Parent = other3.Parent;
  Child = other3.Child;
  AddRemove = other3.AddRemove;
  Type = other3.Type;
  __isset = other3.__isset;
  return *this;
}
void MAttachmentManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAttachmentManipulation(";
  out << "Parent=" << to_string(Parent);
  out << ", " << "Child=" << to_string(Child);
  out << ", " << "AddRemove=" << to_string(AddRemove);
  out << ", " << "Type="; (__isset.Type ? (out << to_string(Type)) : (out << "<null>"));
  out << ")";
}


MPropertyManipulation::~MPropertyManipulation() noexcept {
}


void MPropertyManipulation::__set_Target(const std::string& val) {
  this->Target = val;
}

void MPropertyManipulation::__set_Key(const std::string& val) {
  this->Key = val;
}

void MPropertyManipulation::__set_AddRemove(const bool val) {
  this->AddRemove = val;
}

void MPropertyManipulation::__set_Value(const std::string& val) {
  this->Value = val;
__isset.Value = true;
}
std::ostream& operator<<(std::ostream& out, const MPropertyManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPropertyManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;
  bool isset_Key = false;
  bool isset_AddRemove = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Key);
          isset_Key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->AddRemove);
          isset_AddRemove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_AddRemove)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPropertyManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPropertyManipulation");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Key", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AddRemove", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->AddRemove);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Value) {
    xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPropertyManipulation &a, MPropertyManipulation &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Key, b.Key);
  swap(a.AddRemove, b.AddRemove);
  swap(a.Value, b.Value);
  swap(a.__isset, b.__isset);
}

MPropertyManipulation::MPropertyManipulation(const MPropertyManipulation& other4) {
  Target = other4.Target;
  Key = other4.Key;
  AddRemove = other4.AddRemove;
  Value = other4.Value;
  __isset = other4.__isset;
}
MPropertyManipulation& MPropertyManipulation::operator=(const MPropertyManipulation& other5) {
  Target = other5.Target;
  Key = other5.Key;
  AddRemove = other5.AddRemove;
  Value = other5.Value;
  __isset = other5.__isset;
  return *this;
}
void MPropertyManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPropertyManipulation(";
  out << "Target=" << to_string(Target);
  out << ", " << "Key=" << to_string(Key);
  out << ", " << "AddRemove=" << to_string(AddRemove);
  out << ", " << "Value="; (__isset.Value ? (out << to_string(Value)) : (out << "<null>"));
  out << ")";
}


MTransformUpdate::~MTransformUpdate() noexcept {
}


void MTransformUpdate::__set_Position(const std::vector<double> & val) {
  this->Position = val;
__isset.Position = true;
}

void MTransformUpdate::__set_Rotation(const std::vector<double> & val) {
  this->Rotation = val;
__isset.Rotation = true;
}

void MTransformUpdate::__set_Parent(const std::string& val) {
  this->Parent = val;
__isset.Parent = true;
}
std::ostream& operator<<(std::ostream& out, const MTransformUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTransformUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Position.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->Position.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readDouble(this->Position[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Rotation.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->Rotation.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += iprot->readDouble(this->Rotation[_i15]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          this->__isset.Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MTransformUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTransformUpdate");

  if (this->__isset.Position) {
    xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Position.size()));
      std::vector<double> ::const_iterator _iter16;
      for (_iter16 = this->Position.begin(); _iter16 != this->Position.end(); ++_iter16)
      {
        xfer += oprot->writeDouble((*_iter16));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Rotation) {
    xfer += oprot->writeFieldBegin("Rotation", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Rotation.size()));
      std::vector<double> ::const_iterator _iter17;
      for (_iter17 = this->Rotation.begin(); _iter17 != this->Rotation.end(); ++_iter17)
      {
        xfer += oprot->writeDouble((*_iter17));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Parent) {
    xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->Parent);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTransformUpdate &a, MTransformUpdate &b) {
  using ::std::swap;
  swap(a.Position, b.Position);
  swap(a.Rotation, b.Rotation);
  swap(a.Parent, b.Parent);
  swap(a.__isset, b.__isset);
}

MTransformUpdate::MTransformUpdate(const MTransformUpdate& other18) {
  Position = other18.Position;
  Rotation = other18.Rotation;
  Parent = other18.Parent;
  __isset = other18.__isset;
}
MTransformUpdate& MTransformUpdate::operator=(const MTransformUpdate& other19) {
  Position = other19.Position;
  Rotation = other19.Rotation;
  Parent = other19.Parent;
  __isset = other19.__isset;
  return *this;
}
void MTransformUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTransformUpdate(";
  out << "Position="; (__isset.Position ? (out << to_string(Position)) : (out << "<null>"));
  out << ", " << "Rotation="; (__isset.Rotation ? (out << to_string(Rotation)) : (out << "<null>"));
  out << ", " << "Parent="; (__isset.Parent ? (out << to_string(Parent)) : (out << "<null>"));
  out << ")";
}


MPropertyUpdate::~MPropertyUpdate() noexcept {
}


void MPropertyUpdate::__set_Key(const std::string& val) {
  this->Key = val;
}

void MPropertyUpdate::__set_Value(const std::string& val) {
  this->Value = val;
__isset.Value = true;
}
std::ostream& operator<<(std::ostream& out, const MPropertyUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPropertyUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Key = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Key);
          isset_Key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Value);
          this->__isset.Value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Key)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPropertyUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPropertyUpdate");

  xfer += oprot->writeFieldBegin("Key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Key);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Value) {
    xfer += oprot->writeFieldBegin("Value", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->Value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPropertyUpdate &a, MPropertyUpdate &b) {
  using ::std::swap;
  swap(a.Key, b.Key);
  swap(a.Value, b.Value);
  swap(a.__isset, b.__isset);
}

MPropertyUpdate::MPropertyUpdate(const MPropertyUpdate& other20) {
  Key = other20.Key;
  Value = other20.Value;
  __isset = other20.__isset;
}
MPropertyUpdate& MPropertyUpdate::operator=(const MPropertyUpdate& other21) {
  Key = other21.Key;
  Value = other21.Value;
  __isset = other21.__isset;
  return *this;
}
void MPropertyUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPropertyUpdate(";
  out << "Key=" << to_string(Key);
  out << ", " << "Value="; (__isset.Value ? (out << to_string(Value)) : (out << "<null>"));
  out << ")";
}


MPhysicsProperties::~MPhysicsProperties() noexcept {
}


void MPhysicsProperties::__set_Mass(const double val) {
  this->Mass = val;
}

void MPhysicsProperties::__set_CenterOfMass(const std::vector<double> & val) {
  this->CenterOfMass = val;
}

void MPhysicsProperties::__set_Inertia(const std::vector<double> & val) {
  this->Inertia = val;
__isset.Inertia = true;
}

void MPhysicsProperties::__set_Velocity(const std::vector<double> & val) {
  this->Velocity = val;
__isset.Velocity = true;
}

void MPhysicsProperties::__set_AngularVelocity(const std::vector<double> & val) {
  this->AngularVelocity = val;
__isset.AngularVelocity = true;
}

void MPhysicsProperties::__set_NetForce(const std::vector<double> & val) {
  this->NetForce = val;
__isset.NetForce = true;
}

void MPhysicsProperties::__set_NetTorque(const std::vector<double> & val) {
  this->NetTorque = val;
__isset.NetTorque = true;
}

void MPhysicsProperties::__set_Mu1(const double val) {
  this->Mu1 = val;
__isset.Mu1 = true;
}

void MPhysicsProperties::__set_Mu2(const double val) {
  this->Mu2 = val;
__isset.Mu2 = true;
}

void MPhysicsProperties::__set_Bounciness(const double val) {
  this->Bounciness = val;
__isset.Bounciness = true;
}

void MPhysicsProperties::__set_MuTorsion(const double val) {
  this->MuTorsion = val;
__isset.MuTorsion = true;
}

void MPhysicsProperties::__set_TorsionSurfaceRadius(const double val) {
  this->TorsionSurfaceRadius = val;
__isset.TorsionSurfaceRadius = true;
}
std::ostream& operator<<(std::ostream& out, const MPhysicsProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPhysicsProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Mass = false;
  bool isset_CenterOfMass = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mass);
          isset_Mass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->CenterOfMass.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _etype25;
            xfer += iprot->readListBegin(_etype25, _size22);
            this->CenterOfMass.resize(_size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              xfer += iprot->readDouble(this->CenterOfMass[_i26]);
            }
            xfer += iprot->readListEnd();
          }
          isset_CenterOfMass = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Inertia.clear();
            uint32_t _size27;
            ::apache::thrift::protocol::TType _etype30;
            xfer += iprot->readListBegin(_etype30, _size27);
            this->Inertia.resize(_size27);
            uint32_t _i31;
            for (_i31 = 0; _i31 < _size27; ++_i31)
            {
              xfer += iprot->readDouble(this->Inertia[_i31]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Inertia = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Velocity.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->Velocity.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += iprot->readDouble(this->Velocity[_i36]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Velocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AngularVelocity.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->AngularVelocity.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += iprot->readDouble(this->AngularVelocity[_i41]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AngularVelocity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->NetForce.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _etype45;
            xfer += iprot->readListBegin(_etype45, _size42);
            this->NetForce.resize(_size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              xfer += iprot->readDouble(this->NetForce[_i46]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.NetForce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->NetTorque.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->NetTorque.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readDouble(this->NetTorque[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.NetTorque = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mu1);
          this->__isset.Mu1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Mu2);
          this->__isset.Mu2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Bounciness);
          this->__isset.Bounciness = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->MuTorsion);
          this->__isset.MuTorsion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->TorsionSurfaceRadius);
          this->__isset.TorsionSurfaceRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Mass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_CenterOfMass)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPhysicsProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPhysicsProperties");

  xfer += oprot->writeFieldBegin("Mass", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Mass);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("CenterOfMass", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->CenterOfMass.size()));
    std::vector<double> ::const_iterator _iter52;
    for (_iter52 = this->CenterOfMass.begin(); _iter52 != this->CenterOfMass.end(); ++_iter52)
    {
      xfer += oprot->writeDouble((*_iter52));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Inertia) {
    xfer += oprot->writeFieldBegin("Inertia", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Inertia.size()));
      std::vector<double> ::const_iterator _iter53;
      for (_iter53 = this->Inertia.begin(); _iter53 != this->Inertia.end(); ++_iter53)
      {
        xfer += oprot->writeDouble((*_iter53));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Velocity) {
    xfer += oprot->writeFieldBegin("Velocity", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Velocity.size()));
      std::vector<double> ::const_iterator _iter54;
      for (_iter54 = this->Velocity.begin(); _iter54 != this->Velocity.end(); ++_iter54)
      {
        xfer += oprot->writeDouble((*_iter54));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AngularVelocity) {
    xfer += oprot->writeFieldBegin("AngularVelocity", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->AngularVelocity.size()));
      std::vector<double> ::const_iterator _iter55;
      for (_iter55 = this->AngularVelocity.begin(); _iter55 != this->AngularVelocity.end(); ++_iter55)
      {
        xfer += oprot->writeDouble((*_iter55));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.NetForce) {
    xfer += oprot->writeFieldBegin("NetForce", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->NetForce.size()));
      std::vector<double> ::const_iterator _iter56;
      for (_iter56 = this->NetForce.begin(); _iter56 != this->NetForce.end(); ++_iter56)
      {
        xfer += oprot->writeDouble((*_iter56));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.NetTorque) {
    xfer += oprot->writeFieldBegin("NetTorque", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->NetTorque.size()));
      std::vector<double> ::const_iterator _iter57;
      for (_iter57 = this->NetTorque.begin(); _iter57 != this->NetTorque.end(); ++_iter57)
      {
        xfer += oprot->writeDouble((*_iter57));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mu1) {
    xfer += oprot->writeFieldBegin("Mu1", ::apache::thrift::protocol::T_DOUBLE, 8);
    xfer += oprot->writeDouble(this->Mu1);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mu2) {
    xfer += oprot->writeFieldBegin("Mu2", ::apache::thrift::protocol::T_DOUBLE, 9);
    xfer += oprot->writeDouble(this->Mu2);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Bounciness) {
    xfer += oprot->writeFieldBegin("Bounciness", ::apache::thrift::protocol::T_DOUBLE, 10);
    xfer += oprot->writeDouble(this->Bounciness);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MuTorsion) {
    xfer += oprot->writeFieldBegin("MuTorsion", ::apache::thrift::protocol::T_DOUBLE, 11);
    xfer += oprot->writeDouble(this->MuTorsion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.TorsionSurfaceRadius) {
    xfer += oprot->writeFieldBegin("TorsionSurfaceRadius", ::apache::thrift::protocol::T_DOUBLE, 12);
    xfer += oprot->writeDouble(this->TorsionSurfaceRadius);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPhysicsProperties &a, MPhysicsProperties &b) {
  using ::std::swap;
  swap(a.Mass, b.Mass);
  swap(a.CenterOfMass, b.CenterOfMass);
  swap(a.Inertia, b.Inertia);
  swap(a.Velocity, b.Velocity);
  swap(a.AngularVelocity, b.AngularVelocity);
  swap(a.NetForce, b.NetForce);
  swap(a.NetTorque, b.NetTorque);
  swap(a.Mu1, b.Mu1);
  swap(a.Mu2, b.Mu2);
  swap(a.Bounciness, b.Bounciness);
  swap(a.MuTorsion, b.MuTorsion);
  swap(a.TorsionSurfaceRadius, b.TorsionSurfaceRadius);
  swap(a.__isset, b.__isset);
}

MPhysicsProperties::MPhysicsProperties(const MPhysicsProperties& other58) {
  Mass = other58.Mass;
  CenterOfMass = other58.CenterOfMass;
  Inertia = other58.Inertia;
  Velocity = other58.Velocity;
  AngularVelocity = other58.AngularVelocity;
  NetForce = other58.NetForce;
  NetTorque = other58.NetTorque;
  Mu1 = other58.Mu1;
  Mu2 = other58.Mu2;
  Bounciness = other58.Bounciness;
  MuTorsion = other58.MuTorsion;
  TorsionSurfaceRadius = other58.TorsionSurfaceRadius;
  __isset = other58.__isset;
}
MPhysicsProperties& MPhysicsProperties::operator=(const MPhysicsProperties& other59) {
  Mass = other59.Mass;
  CenterOfMass = other59.CenterOfMass;
  Inertia = other59.Inertia;
  Velocity = other59.Velocity;
  AngularVelocity = other59.AngularVelocity;
  NetForce = other59.NetForce;
  NetTorque = other59.NetTorque;
  Mu1 = other59.Mu1;
  Mu2 = other59.Mu2;
  Bounciness = other59.Bounciness;
  MuTorsion = other59.MuTorsion;
  TorsionSurfaceRadius = other59.TorsionSurfaceRadius;
  __isset = other59.__isset;
  return *this;
}
void MPhysicsProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPhysicsProperties(";
  out << "Mass=" << to_string(Mass);
  out << ", " << "CenterOfMass=" << to_string(CenterOfMass);
  out << ", " << "Inertia="; (__isset.Inertia ? (out << to_string(Inertia)) : (out << "<null>"));
  out << ", " << "Velocity="; (__isset.Velocity ? (out << to_string(Velocity)) : (out << "<null>"));
  out << ", " << "AngularVelocity="; (__isset.AngularVelocity ? (out << to_string(AngularVelocity)) : (out << "<null>"));
  out << ", " << "NetForce="; (__isset.NetForce ? (out << to_string(NetForce)) : (out << "<null>"));
  out << ", " << "NetTorque="; (__isset.NetTorque ? (out << to_string(NetTorque)) : (out << "<null>"));
  out << ", " << "Mu1="; (__isset.Mu1 ? (out << to_string(Mu1)) : (out << "<null>"));
  out << ", " << "Mu2="; (__isset.Mu2 ? (out << to_string(Mu2)) : (out << "<null>"));
  out << ", " << "Bounciness="; (__isset.Bounciness ? (out << to_string(Bounciness)) : (out << "<null>"));
  out << ", " << "MuTorsion="; (__isset.MuTorsion ? (out << to_string(MuTorsion)) : (out << "<null>"));
  out << ", " << "TorsionSurfaceRadius="; (__isset.TorsionSurfaceRadius ? (out << to_string(TorsionSurfaceRadius)) : (out << "<null>"));
  out << ")";
}


MSphereColliderProperties::~MSphereColliderProperties() noexcept {
}


void MSphereColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}
std::ostream& operator<<(std::ostream& out, const MSphereColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSphereColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSphereColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSphereColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSphereColliderProperties &a, MSphereColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
}

MSphereColliderProperties::MSphereColliderProperties(const MSphereColliderProperties& other60) {
  Radius = other60.Radius;
}
MSphereColliderProperties& MSphereColliderProperties::operator=(const MSphereColliderProperties& other61) {
  Radius = other61.Radius;
  return *this;
}
void MSphereColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSphereColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ")";
}


MConeColliderProperties::~MConeColliderProperties() noexcept {
}


void MConeColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MConeColliderProperties::__set_Height(const double val) {
  this->Height = val;
}
std::ostream& operator<<(std::ostream& out, const MConeColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MConeColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MConeColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MConeColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MConeColliderProperties &a, MConeColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
}

MConeColliderProperties::MConeColliderProperties(const MConeColliderProperties& other62) {
  Radius = other62.Radius;
  Height = other62.Height;
}
MConeColliderProperties& MConeColliderProperties::operator=(const MConeColliderProperties& other63) {
  Radius = other63.Radius;
  Height = other63.Height;
  return *this;
}
void MConeColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MConeColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ")";
}


MCylinderColliderProperties::~MCylinderColliderProperties() noexcept {
}


void MCylinderColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MCylinderColliderProperties::__set_Height(const double val) {
  this->Height = val;
}
std::ostream& operator<<(std::ostream& out, const MCylinderColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCylinderColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCylinderColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCylinderColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCylinderColliderProperties &a, MCylinderColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
}

MCylinderColliderProperties::MCylinderColliderProperties(const MCylinderColliderProperties& other64) {
  Radius = other64.Radius;
  Height = other64.Height;
}
MCylinderColliderProperties& MCylinderColliderProperties::operator=(const MCylinderColliderProperties& other65) {
  Radius = other65.Radius;
  Height = other65.Height;
  return *this;
}
void MCylinderColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCylinderColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ")";
}


MTransformManipulation::~MTransformManipulation() noexcept {
}


void MTransformManipulation::__set_Target(const std::string& val) {
  this->Target = val;
}

void MTransformManipulation::__set_Position(const  ::MMIStandard::MVector3& val) {
  this->Position = val;
__isset.Position = true;
}

void MTransformManipulation::__set_Rotation(const  ::MMIStandard::MQuaternion& val) {
  this->Rotation = val;
__isset.Rotation = true;
}

void MTransformManipulation::__set_Parent(const std::string& val) {
  this->Parent = val;
__isset.Parent = true;
}
std::ostream& operator<<(std::ostream& out, const MTransformManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MTransformManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Position.read(iprot);
          this->__isset.Position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Rotation.read(iprot);
          this->__isset.Rotation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Parent);
          this->__isset.Parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MTransformManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MTransformManipulation");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Position) {
    xfer += oprot->writeFieldBegin("Position", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->Position.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Rotation) {
    xfer += oprot->writeFieldBegin("Rotation", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->Rotation.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Parent) {
    xfer += oprot->writeFieldBegin("Parent", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->Parent);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MTransformManipulation &a, MTransformManipulation &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Position, b.Position);
  swap(a.Rotation, b.Rotation);
  swap(a.Parent, b.Parent);
  swap(a.__isset, b.__isset);
}

MTransformManipulation::MTransformManipulation(const MTransformManipulation& other66) {
  Target = other66.Target;
  Position = other66.Position;
  Rotation = other66.Rotation;
  Parent = other66.Parent;
  __isset = other66.__isset;
}
MTransformManipulation& MTransformManipulation::operator=(const MTransformManipulation& other67) {
  Target = other67.Target;
  Position = other67.Position;
  Rotation = other67.Rotation;
  Parent = other67.Parent;
  __isset = other67.__isset;
  return *this;
}
void MTransformManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MTransformManipulation(";
  out << "Target=" << to_string(Target);
  out << ", " << "Position="; (__isset.Position ? (out << to_string(Position)) : (out << "<null>"));
  out << ", " << "Rotation="; (__isset.Rotation ? (out << to_string(Rotation)) : (out << "<null>"));
  out << ", " << "Parent="; (__isset.Parent ? (out << to_string(Parent)) : (out << "<null>"));
  out << ")";
}


MBoxColliderProperties::~MBoxColliderProperties() noexcept {
}


void MBoxColliderProperties::__set_Size(const  ::MMIStandard::MVector3& val) {
  this->Size = val;
}
std::ostream& operator<<(std::ostream& out, const MBoxColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MBoxColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Size.read(iprot);
          isset_Size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MBoxColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MBoxColliderProperties");

  xfer += oprot->writeFieldBegin("Size", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Size.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MBoxColliderProperties &a, MBoxColliderProperties &b) {
  using ::std::swap;
  swap(a.Size, b.Size);
}

MBoxColliderProperties::MBoxColliderProperties(const MBoxColliderProperties& other68) {
  Size = other68.Size;
}
MBoxColliderProperties& MBoxColliderProperties::operator=(const MBoxColliderProperties& other69) {
  Size = other69.Size;
  return *this;
}
void MBoxColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MBoxColliderProperties(";
  out << "Size=" << to_string(Size);
  out << ")";
}


MCapsuleColliderProperties::~MCapsuleColliderProperties() noexcept {
}


void MCapsuleColliderProperties::__set_Radius(const double val) {
  this->Radius = val;
}

void MCapsuleColliderProperties::__set_Height(const double val) {
  this->Height = val;
}

void MCapsuleColliderProperties::__set_MainAxis(const  ::MMIStandard::MVector3& val) {
  this->MainAxis = val;
__isset.MainAxis = true;
}
std::ostream& operator<<(std::ostream& out, const MCapsuleColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCapsuleColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Radius = false;
  bool isset_Height = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Radius);
          isset_Radius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->Height);
          isset_Height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MainAxis.read(iprot);
          this->__isset.MainAxis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Radius)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCapsuleColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCapsuleColliderProperties");

  xfer += oprot->writeFieldBegin("Radius", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->Radius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Height", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->Height);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.MainAxis) {
    xfer += oprot->writeFieldBegin("MainAxis", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->MainAxis.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCapsuleColliderProperties &a, MCapsuleColliderProperties &b) {
  using ::std::swap;
  swap(a.Radius, b.Radius);
  swap(a.Height, b.Height);
  swap(a.MainAxis, b.MainAxis);
  swap(a.__isset, b.__isset);
}

MCapsuleColliderProperties::MCapsuleColliderProperties(const MCapsuleColliderProperties& other70) {
  Radius = other70.Radius;
  Height = other70.Height;
  MainAxis = other70.MainAxis;
  __isset = other70.__isset;
}
MCapsuleColliderProperties& MCapsuleColliderProperties::operator=(const MCapsuleColliderProperties& other71) {
  Radius = other71.Radius;
  Height = other71.Height;
  MainAxis = other71.MainAxis;
  __isset = other71.__isset;
  return *this;
}
void MCapsuleColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCapsuleColliderProperties(";
  out << "Radius=" << to_string(Radius);
  out << ", " << "Height=" << to_string(Height);
  out << ", " << "MainAxis="; (__isset.MainAxis ? (out << to_string(MainAxis)) : (out << "<null>"));
  out << ")";
}


MMeshColliderProperties::~MMeshColliderProperties() noexcept {
}


void MMeshColliderProperties::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MMeshColliderProperties::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}
std::ostream& operator<<(std::ostream& out, const MMeshColliderProperties& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MMeshColliderProperties::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size72;
            ::apache::thrift::protocol::TType _etype75;
            xfer += iprot->readListBegin(_etype75, _size72);
            this->Vertices.resize(_size72);
            uint32_t _i76;
            for (_i76 = 0; _i76 < _size72; ++_i76)
            {
              xfer += this->Vertices[_i76].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->Triangles.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += iprot->readI32(this->Triangles[_i81]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MMeshColliderProperties::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MMeshColliderProperties");

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter82;
    for (_iter82 = this->Vertices.begin(); _iter82 != this->Vertices.end(); ++_iter82)
    {
      xfer += (*_iter82).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter83;
    for (_iter83 = this->Triangles.begin(); _iter83 != this->Triangles.end(); ++_iter83)
    {
      xfer += oprot->writeI32((*_iter83));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MMeshColliderProperties &a, MMeshColliderProperties &b) {
  using ::std::swap;
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
}

MMeshColliderProperties::MMeshColliderProperties(const MMeshColliderProperties& other84) {
  Vertices = other84.Vertices;
  Triangles = other84.Triangles;
}
MMeshColliderProperties& MMeshColliderProperties::operator=(const MMeshColliderProperties& other85) {
  Vertices = other85.Vertices;
  Triangles = other85.Triangles;
  return *this;
}
void MMeshColliderProperties::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MMeshColliderProperties(";
  out << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ")";
}


MMesh::~MMesh() noexcept {
}


void MMesh::__set_ID(const std::string& val) {
  this->ID = val;
}

void MMesh::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MMesh::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}

void MMesh::__set_UVCoordinates(const std::vector< ::MMIStandard::MVector2> & val) {
  this->UVCoordinates = val;
__isset.UVCoordinates = true;
}

void MMesh::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MMesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MMesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->Vertices.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->Vertices[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size91;
            ::apache::thrift::protocol::TType _etype94;
            xfer += iprot->readListBegin(_etype94, _size91);
            this->Triangles.resize(_size91);
            uint32_t _i95;
            for (_i95 = 0; _i95 < _size91; ++_i95)
            {
              xfer += iprot->readI32(this->Triangles[_i95]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->UVCoordinates.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->UVCoordinates.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += this->UVCoordinates[_i100].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.UVCoordinates = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _ktype102;
            ::apache::thrift::protocol::TType _vtype103;
            xfer += iprot->readMapBegin(_ktype102, _vtype103, _size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              std::string _key106;
              xfer += iprot->readString(_key106);
              std::string& _val107 = this->Properties[_key106];
              xfer += iprot->readString(_val107);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MMesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MMesh");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter108;
    for (_iter108 = this->Vertices.begin(); _iter108 != this->Vertices.end(); ++_iter108)
    {
      xfer += (*_iter108).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter109;
    for (_iter109 = this->Triangles.begin(); _iter109 != this->Triangles.end(); ++_iter109)
    {
      xfer += oprot->writeI32((*_iter109));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.UVCoordinates) {
    xfer += oprot->writeFieldBegin("UVCoordinates", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->UVCoordinates.size()));
      std::vector< ::MMIStandard::MVector2> ::const_iterator _iter110;
      for (_iter110 = this->UVCoordinates.begin(); _iter110 != this->UVCoordinates.end(); ++_iter110)
      {
        xfer += (*_iter110).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 5);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter111;
      for (_iter111 = this->Properties.begin(); _iter111 != this->Properties.end(); ++_iter111)
      {
        xfer += oprot->writeString(_iter111->first);
        xfer += oprot->writeString(_iter111->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MMesh &a, MMesh &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
  swap(a.UVCoordinates, b.UVCoordinates);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MMesh::MMesh(const MMesh& other112) {
  ID = other112.ID;
  Vertices = other112.Vertices;
  Triangles = other112.Triangles;
  UVCoordinates = other112.UVCoordinates;
  Properties = other112.Properties;
  __isset = other112.__isset;
}
MMesh& MMesh::operator=(const MMesh& other113) {
  ID = other113.ID;
  Vertices = other113.Vertices;
  Triangles = other113.Triangles;
  UVCoordinates = other113.UVCoordinates;
  Properties = other113.Properties;
  __isset = other113.__isset;
  return *this;
}
void MMesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MMesh(";
  out << "ID=" << to_string(ID);
  out << ", " << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ", " << "UVCoordinates="; (__isset.UVCoordinates ? (out << to_string(UVCoordinates)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MNavigationMesh::~MNavigationMesh() noexcept {
}


void MNavigationMesh::__set_Vertices(const std::vector< ::MMIStandard::MVector3> & val) {
  this->Vertices = val;
}

void MNavigationMesh::__set_Triangles(const std::vector<int32_t> & val) {
  this->Triangles = val;
}

void MNavigationMesh::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MNavigationMesh& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MNavigationMesh::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Vertices = false;
  bool isset_Triangles = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Vertices.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->Vertices.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += this->Vertices[_i118].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_Vertices = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Triangles.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->Triangles.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readI32(this->Triangles[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Triangles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size124;
            ::apache::thrift::protocol::TType _ktype125;
            ::apache::thrift::protocol::TType _vtype126;
            xfer += iprot->readMapBegin(_ktype125, _vtype126, _size124);
            uint32_t _i128;
            for (_i128 = 0; _i128 < _size124; ++_i128)
            {
              std::string _key129;
              xfer += iprot->readString(_key129);
              std::string& _val130 = this->Properties[_key129];
              xfer += iprot->readString(_val130);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Vertices)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Triangles)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MNavigationMesh::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MNavigationMesh");

  xfer += oprot->writeFieldBegin("Vertices", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Vertices.size()));
    std::vector< ::MMIStandard::MVector3> ::const_iterator _iter131;
    for (_iter131 = this->Vertices.begin(); _iter131 != this->Vertices.end(); ++_iter131)
    {
      xfer += (*_iter131).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Triangles", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->Triangles.size()));
    std::vector<int32_t> ::const_iterator _iter132;
    for (_iter132 = this->Triangles.begin(); _iter132 != this->Triangles.end(); ++_iter132)
    {
      xfer += oprot->writeI32((*_iter132));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter133;
      for (_iter133 = this->Properties.begin(); _iter133 != this->Properties.end(); ++_iter133)
      {
        xfer += oprot->writeString(_iter133->first);
        xfer += oprot->writeString(_iter133->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MNavigationMesh &a, MNavigationMesh &b) {
  using ::std::swap;
  swap(a.Vertices, b.Vertices);
  swap(a.Triangles, b.Triangles);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MNavigationMesh::MNavigationMesh(const MNavigationMesh& other134) {
  Vertices = other134.Vertices;
  Triangles = other134.Triangles;
  Properties = other134.Properties;
  __isset = other134.__isset;
}
MNavigationMesh& MNavigationMesh::operator=(const MNavigationMesh& other135) {
  Vertices = other135.Vertices;
  Triangles = other135.Triangles;
  Properties = other135.Properties;
  __isset = other135.__isset;
  return *this;
}
void MNavigationMesh::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MNavigationMesh(";
  out << "Vertices=" << to_string(Vertices);
  out << ", " << "Triangles=" << to_string(Triangles);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MDrawingCall::~MDrawingCall() noexcept {
}


void MDrawingCall::__set_Type(const MDrawingCallType::type val) {
  this->Type = val;
}

void MDrawingCall::__set_Data(const std::vector<double> & val) {
  this->Data = val;
__isset.Data = true;
}

void MDrawingCall::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MDrawingCall& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MDrawingCall::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast136;
          xfer += iprot->readI32(ecast136);
          this->Type = (MDrawingCallType::type)ecast136;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Data.clear();
            uint32_t _size137;
            ::apache::thrift::protocol::TType _etype140;
            xfer += iprot->readListBegin(_etype140, _size137);
            this->Data.resize(_size137);
            uint32_t _i141;
            for (_i141 = 0; _i141 < _size137; ++_i141)
            {
              xfer += iprot->readDouble(this->Data[_i141]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size142;
            ::apache::thrift::protocol::TType _ktype143;
            ::apache::thrift::protocol::TType _vtype144;
            xfer += iprot->readMapBegin(_ktype143, _vtype144, _size142);
            uint32_t _i146;
            for (_i146 = 0; _i146 < _size142; ++_i146)
            {
              std::string _key147;
              xfer += iprot->readString(_key147);
              std::string& _val148 = this->Properties[_key147];
              xfer += iprot->readString(_val148);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MDrawingCall::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MDrawingCall");

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Data) {
    xfer += oprot->writeFieldBegin("Data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Data.size()));
      std::vector<double> ::const_iterator _iter149;
      for (_iter149 = this->Data.begin(); _iter149 != this->Data.end(); ++_iter149)
      {
        xfer += oprot->writeDouble((*_iter149));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter150;
      for (_iter150 = this->Properties.begin(); _iter150 != this->Properties.end(); ++_iter150)
      {
        xfer += oprot->writeString(_iter150->first);
        xfer += oprot->writeString(_iter150->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MDrawingCall &a, MDrawingCall &b) {
  using ::std::swap;
  swap(a.Type, b.Type);
  swap(a.Data, b.Data);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MDrawingCall::MDrawingCall(const MDrawingCall& other151) {
  Type = other151.Type;
  Data = other151.Data;
  Properties = other151.Properties;
  __isset = other151.__isset;
}
MDrawingCall& MDrawingCall::operator=(const MDrawingCall& other152) {
  Type = other152.Type;
  Data = other152.Data;
  Properties = other152.Properties;
  __isset = other152.__isset;
  return *this;
}
void MDrawingCall::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MDrawingCall(";
  out << "Type=" << to_string(Type);
  out << ", " << "Data="; (__isset.Data ? (out << to_string(Data)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MPhysicsInteraction::~MPhysicsInteraction() noexcept {
}


void MPhysicsInteraction::__set_Target(const std::string& val) {
  this->Target = val;
}

void MPhysicsInteraction::__set_Type(const MPhysicsInteractionType::type val) {
  this->Type = val;
}

void MPhysicsInteraction::__set_Values(const std::vector<double> & val) {
  this->Values = val;
}

void MPhysicsInteraction::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MPhysicsInteraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MPhysicsInteraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Target = false;
  bool isset_Type = false;
  bool isset_Values = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Target);
          isset_Target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast153;
          xfer += iprot->readI32(ecast153);
          this->Type = (MPhysicsInteractionType::type)ecast153;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Values.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->Values.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              xfer += iprot->readDouble(this->Values[_i158]);
            }
            xfer += iprot->readListEnd();
          }
          isset_Values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size159;
            ::apache::thrift::protocol::TType _ktype160;
            ::apache::thrift::protocol::TType _vtype161;
            xfer += iprot->readMapBegin(_ktype160, _vtype161, _size159);
            uint32_t _i163;
            for (_i163 = 0; _i163 < _size159; ++_i163)
            {
              std::string _key164;
              xfer += iprot->readString(_key164);
              std::string& _val165 = this->Properties[_key164];
              xfer += iprot->readString(_val165);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Values)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MPhysicsInteraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MPhysicsInteraction");

  xfer += oprot->writeFieldBegin("Target", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Values", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->Values.size()));
    std::vector<double> ::const_iterator _iter166;
    for (_iter166 = this->Values.begin(); _iter166 != this->Values.end(); ++_iter166)
    {
      xfer += oprot->writeDouble((*_iter166));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter167;
      for (_iter167 = this->Properties.begin(); _iter167 != this->Properties.end(); ++_iter167)
      {
        xfer += oprot->writeString(_iter167->first);
        xfer += oprot->writeString(_iter167->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MPhysicsInteraction &a, MPhysicsInteraction &b) {
  using ::std::swap;
  swap(a.Target, b.Target);
  swap(a.Type, b.Type);
  swap(a.Values, b.Values);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MPhysicsInteraction::MPhysicsInteraction(const MPhysicsInteraction& other168) {
  Target = other168.Target;
  Type = other168.Type;
  Values = other168.Values;
  Properties = other168.Properties;
  __isset = other168.__isset;
}
MPhysicsInteraction& MPhysicsInteraction::operator=(const MPhysicsInteraction& other169) {
  Target = other169.Target;
  Type = other169.Type;
  Values = other169.Values;
  Properties = other169.Properties;
  __isset = other169.__isset;
  return *this;
}
void MPhysicsInteraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MPhysicsInteraction(";
  out << "Target=" << to_string(Target);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "Values=" << to_string(Values);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MSceneManipulation::~MSceneManipulation() noexcept {
}


void MSceneManipulation::__set_Transforms(const std::vector<MTransformManipulation> & val) {
  this->Transforms = val;
__isset.Transforms = true;
}

void MSceneManipulation::__set_PhysicsInteractions(const std::vector<MPhysicsInteraction> & val) {
  this->PhysicsInteractions = val;
__isset.PhysicsInteractions = true;
}

void MSceneManipulation::__set_Properties(const std::vector<MPropertyManipulation> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneManipulation::__set_Attachments(const std::vector<MAttachmentManipulation> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneManipulation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneManipulation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Transforms.clear();
            uint32_t _size170;
            ::apache::thrift::protocol::TType _etype173;
            xfer += iprot->readListBegin(_etype173, _size170);
            this->Transforms.resize(_size170);
            uint32_t _i174;
            for (_i174 = 0; _i174 < _size170; ++_i174)
            {
              xfer += this->Transforms[_i174].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Transforms = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->PhysicsInteractions.clear();
            uint32_t _size175;
            ::apache::thrift::protocol::TType _etype178;
            xfer += iprot->readListBegin(_etype178, _size175);
            this->PhysicsInteractions.resize(_size175);
            uint32_t _i179;
            for (_i179 = 0; _i179 < _size175; ++_i179)
            {
              xfer += this->PhysicsInteractions[_i179].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.PhysicsInteractions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size180;
            ::apache::thrift::protocol::TType _etype183;
            xfer += iprot->readListBegin(_etype183, _size180);
            this->Properties.resize(_size180);
            uint32_t _i184;
            for (_i184 = 0; _i184 < _size180; ++_i184)
            {
              xfer += this->Properties[_i184].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size185;
            ::apache::thrift::protocol::TType _etype188;
            xfer += iprot->readListBegin(_etype188, _size185);
            this->Attachments.resize(_size185);
            uint32_t _i189;
            for (_i189 = 0; _i189 < _size185; ++_i189)
            {
              xfer += this->Attachments[_i189].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSceneManipulation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneManipulation");

  if (this->__isset.Transforms) {
    xfer += oprot->writeFieldBegin("Transforms", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Transforms.size()));
      std::vector<MTransformManipulation> ::const_iterator _iter190;
      for (_iter190 = this->Transforms.begin(); _iter190 != this->Transforms.end(); ++_iter190)
      {
        xfer += (*_iter190).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsInteractions) {
    xfer += oprot->writeFieldBegin("PhysicsInteractions", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->PhysicsInteractions.size()));
      std::vector<MPhysicsInteraction> ::const_iterator _iter191;
      for (_iter191 = this->PhysicsInteractions.begin(); _iter191 != this->PhysicsInteractions.end(); ++_iter191)
      {
        xfer += (*_iter191).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyManipulation> ::const_iterator _iter192;
      for (_iter192 = this->Properties.begin(); _iter192 != this->Properties.end(); ++_iter192)
      {
        xfer += (*_iter192).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachmentManipulation> ::const_iterator _iter193;
      for (_iter193 = this->Attachments.begin(); _iter193 != this->Attachments.end(); ++_iter193)
      {
        xfer += (*_iter193).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneManipulation &a, MSceneManipulation &b) {
  using ::std::swap;
  swap(a.Transforms, b.Transforms);
  swap(a.PhysicsInteractions, b.PhysicsInteractions);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.__isset, b.__isset);
}

MSceneManipulation::MSceneManipulation(const MSceneManipulation& other194) {
  Transforms = other194.Transforms;
  PhysicsInteractions = other194.PhysicsInteractions;
  Properties = other194.Properties;
  Attachments = other194.Attachments;
  __isset = other194.__isset;
}
MSceneManipulation& MSceneManipulation::operator=(const MSceneManipulation& other195) {
  Transforms = other195.Transforms;
  PhysicsInteractions = other195.PhysicsInteractions;
  Properties = other195.Properties;
  Attachments = other195.Attachments;
  __isset = other195.__isset;
  return *this;
}
void MSceneManipulation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneManipulation(";
  out << "Transforms="; (__isset.Transforms ? (out << to_string(Transforms)) : (out << "<null>"));
  out << ", " << "PhysicsInteractions="; (__isset.PhysicsInteractions ? (out << to_string(PhysicsInteractions)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ")";
}


MCollider::~MCollider() noexcept {
}


void MCollider::__set_ID(const std::string& val) {
  this->ID = val;
}

void MCollider::__set_Type(const MColliderType::type val) {
  this->Type = val;
}

void MCollider::__set_BoxColliderProperties(const MBoxColliderProperties& val) {
  this->BoxColliderProperties = val;
__isset.BoxColliderProperties = true;
}

void MCollider::__set_SphereColliderProperties(const MSphereColliderProperties& val) {
  this->SphereColliderProperties = val;
__isset.SphereColliderProperties = true;
}

void MCollider::__set_CapsuleColliderProperties(const MCapsuleColliderProperties& val) {
  this->CapsuleColliderProperties = val;
__isset.CapsuleColliderProperties = true;
}

void MCollider::__set_ConeColliderProperties(const MConeColliderProperties& val) {
  this->ConeColliderProperties = val;
__isset.ConeColliderProperties = true;
}

void MCollider::__set_CylinderColliderProperties(const MCylinderColliderProperties& val) {
  this->CylinderColliderProperties = val;
__isset.CylinderColliderProperties = true;
}

void MCollider::__set_MeshColliderProperties(const MMeshColliderProperties& val) {
  this->MeshColliderProperties = val;
__isset.MeshColliderProperties = true;
}

void MCollider::__set_PositionOffset(const  ::MMIStandard::MVector3& val) {
  this->PositionOffset = val;
__isset.PositionOffset = true;
}

void MCollider::__set_RotationOffset(const  ::MMIStandard::MQuaternion& val) {
  this->RotationOffset = val;
__isset.RotationOffset = true;
}

void MCollider::__set_Colliders(const std::vector<MCollider> & val) {
  this->Colliders = val;
__isset.Colliders = true;
}

void MCollider::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MCollider& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MCollider::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Type = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast196;
          xfer += iprot->readI32(ecast196);
          this->Type = (MColliderType::type)ecast196;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->BoxColliderProperties.read(iprot);
          this->__isset.BoxColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->SphereColliderProperties.read(iprot);
          this->__isset.SphereColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->CapsuleColliderProperties.read(iprot);
          this->__isset.CapsuleColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ConeColliderProperties.read(iprot);
          this->__isset.ConeColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->CylinderColliderProperties.read(iprot);
          this->__isset.CylinderColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MeshColliderProperties.read(iprot);
          this->__isset.MeshColliderProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PositionOffset.read(iprot);
          this->__isset.PositionOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->RotationOffset.read(iprot);
          this->__isset.RotationOffset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Colliders.clear();
            uint32_t _size197;
            ::apache::thrift::protocol::TType _etype200;
            xfer += iprot->readListBegin(_etype200, _size197);
            this->Colliders.resize(_size197);
            uint32_t _i201;
            for (_i201 = 0; _i201 < _size197; ++_i201)
            {
              xfer += this->Colliders[_i201].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Colliders = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size202;
            ::apache::thrift::protocol::TType _ktype203;
            ::apache::thrift::protocol::TType _vtype204;
            xfer += iprot->readMapBegin(_ktype203, _vtype204, _size202);
            uint32_t _i206;
            for (_i206 = 0; _i206 < _size202; ++_i206)
            {
              std::string _key207;
              xfer += iprot->readString(_key207);
              std::string& _val208 = this->Properties[_key207];
              xfer += iprot->readString(_val208);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MCollider::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MCollider");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.BoxColliderProperties) {
    xfer += oprot->writeFieldBegin("BoxColliderProperties", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->BoxColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SphereColliderProperties) {
    xfer += oprot->writeFieldBegin("SphereColliderProperties", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->SphereColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.CapsuleColliderProperties) {
    xfer += oprot->writeFieldBegin("CapsuleColliderProperties", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->CapsuleColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ConeColliderProperties) {
    xfer += oprot->writeFieldBegin("ConeColliderProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->ConeColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.CylinderColliderProperties) {
    xfer += oprot->writeFieldBegin("CylinderColliderProperties", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->CylinderColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.MeshColliderProperties) {
    xfer += oprot->writeFieldBegin("MeshColliderProperties", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->MeshColliderProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PositionOffset) {
    xfer += oprot->writeFieldBegin("PositionOffset", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->PositionOffset.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RotationOffset) {
    xfer += oprot->writeFieldBegin("RotationOffset", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->RotationOffset.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Colliders) {
    xfer += oprot->writeFieldBegin("Colliders", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Colliders.size()));
      std::vector<MCollider> ::const_iterator _iter209;
      for (_iter209 = this->Colliders.begin(); _iter209 != this->Colliders.end(); ++_iter209)
      {
        xfer += (*_iter209).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 12);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter210;
      for (_iter210 = this->Properties.begin(); _iter210 != this->Properties.end(); ++_iter210)
      {
        xfer += oprot->writeString(_iter210->first);
        xfer += oprot->writeString(_iter210->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MCollider &a, MCollider &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Type, b.Type);
  swap(a.BoxColliderProperties, b.BoxColliderProperties);
  swap(a.SphereColliderProperties, b.SphereColliderProperties);
  swap(a.CapsuleColliderProperties, b.CapsuleColliderProperties);
  swap(a.ConeColliderProperties, b.ConeColliderProperties);
  swap(a.CylinderColliderProperties, b.CylinderColliderProperties);
  swap(a.MeshColliderProperties, b.MeshColliderProperties);
  swap(a.PositionOffset, b.PositionOffset);
  swap(a.RotationOffset, b.RotationOffset);
  swap(a.Colliders, b.Colliders);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MCollider::MCollider(const MCollider& other211) {
  ID = other211.ID;
  Type = other211.Type;
  BoxColliderProperties = other211.BoxColliderProperties;
  SphereColliderProperties = other211.SphereColliderProperties;
  CapsuleColliderProperties = other211.CapsuleColliderProperties;
  ConeColliderProperties = other211.ConeColliderProperties;
  CylinderColliderProperties = other211.CylinderColliderProperties;
  MeshColliderProperties = other211.MeshColliderProperties;
  PositionOffset = other211.PositionOffset;
  RotationOffset = other211.RotationOffset;
  Colliders = other211.Colliders;
  Properties = other211.Properties;
  __isset = other211.__isset;
}
MCollider& MCollider::operator=(const MCollider& other212) {
  ID = other212.ID;
  Type = other212.Type;
  BoxColliderProperties = other212.BoxColliderProperties;
  SphereColliderProperties = other212.SphereColliderProperties;
  CapsuleColliderProperties = other212.CapsuleColliderProperties;
  ConeColliderProperties = other212.ConeColliderProperties;
  CylinderColliderProperties = other212.CylinderColliderProperties;
  MeshColliderProperties = other212.MeshColliderProperties;
  PositionOffset = other212.PositionOffset;
  RotationOffset = other212.RotationOffset;
  Colliders = other212.Colliders;
  Properties = other212.Properties;
  __isset = other212.__isset;
  return *this;
}
void MCollider::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MCollider(";
  out << "ID=" << to_string(ID);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "BoxColliderProperties="; (__isset.BoxColliderProperties ? (out << to_string(BoxColliderProperties)) : (out << "<null>"));
  out << ", " << "SphereColliderProperties="; (__isset.SphereColliderProperties ? (out << to_string(SphereColliderProperties)) : (out << "<null>"));
  out << ", " << "CapsuleColliderProperties="; (__isset.CapsuleColliderProperties ? (out << to_string(CapsuleColliderProperties)) : (out << "<null>"));
  out << ", " << "ConeColliderProperties="; (__isset.ConeColliderProperties ? (out << to_string(ConeColliderProperties)) : (out << "<null>"));
  out << ", " << "CylinderColliderProperties="; (__isset.CylinderColliderProperties ? (out << to_string(CylinderColliderProperties)) : (out << "<null>"));
  out << ", " << "MeshColliderProperties="; (__isset.MeshColliderProperties ? (out << to_string(MeshColliderProperties)) : (out << "<null>"));
  out << ", " << "PositionOffset="; (__isset.PositionOffset ? (out << to_string(PositionOffset)) : (out << "<null>"));
  out << ", " << "RotationOffset="; (__isset.RotationOffset ? (out << to_string(RotationOffset)) : (out << "<null>"));
  out << ", " << "Colliders="; (__isset.Colliders ? (out << to_string(Colliders)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MSceneObject::~MSceneObject() noexcept {
}


void MSceneObject::__set_ID(const std::string& val) {
  this->ID = val;
}

void MSceneObject::__set_Name(const std::string& val) {
  this->Name = val;
}

void MSceneObject::__set_Transform(const  ::MMIStandard::MTransform& val) {
  this->Transform = val;
}

void MSceneObject::__set_Collider(const MCollider& val) {
  this->Collider = val;
__isset.Collider = true;
}

void MSceneObject::__set_Mesh(const MMesh& val) {
  this->Mesh = val;
__isset.Mesh = true;
}

void MSceneObject::__set_PhysicsProperties(const MPhysicsProperties& val) {
  this->PhysicsProperties = val;
__isset.PhysicsProperties = true;
}

void MSceneObject::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneObject::__set_Attachments(const std::vector<MAttachment> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}

void MSceneObject::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneObject& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Name = false;
  bool isset_Transform = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          isset_Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Transform.read(iprot);
          isset_Transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Collider.read(iprot);
          this->__isset.Collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Mesh.read(iprot);
          this->__isset.Mesh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PhysicsProperties.read(iprot);
          this->__isset.PhysicsProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _ktype214;
            ::apache::thrift::protocol::TType _vtype215;
            xfer += iprot->readMapBegin(_ktype214, _vtype215, _size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              std::string _key218;
              xfer += iprot->readString(_key218);
              std::string& _val219 = this->Properties[_key218];
              xfer += iprot->readString(_val219);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size220;
            ::apache::thrift::protocol::TType _etype223;
            xfer += iprot->readListBegin(_etype223, _size220);
            this->Attachments.resize(_size220);
            uint32_t _i224;
            for (_i224 = 0; _i224 < _size220; ++_i224)
            {
              xfer += this->Attachments[_i224].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size225;
            ::apache::thrift::protocol::TType _etype228;
            xfer += iprot->readListBegin(_etype228, _size225);
            this->Constraints.resize(_size225);
            uint32_t _i229;
            for (_i229 = 0; _i229 < _size225; ++_i229)
            {
              xfer += this->Constraints[_i229].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Transform)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSceneObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneObject");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Transform", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->Transform.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Collider) {
    xfer += oprot->writeFieldBegin("Collider", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Collider.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mesh) {
    xfer += oprot->writeFieldBegin("Mesh", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->Mesh.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsProperties) {
    xfer += oprot->writeFieldBegin("PhysicsProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->PhysicsProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter230;
      for (_iter230 = this->Properties.begin(); _iter230 != this->Properties.end(); ++_iter230)
      {
        xfer += oprot->writeString(_iter230->first);
        xfer += oprot->writeString(_iter230->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachment> ::const_iterator _iter231;
      for (_iter231 = this->Attachments.begin(); _iter231 != this->Attachments.end(); ++_iter231)
      {
        xfer += (*_iter231).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter232;
      for (_iter232 = this->Constraints.begin(); _iter232 != this->Constraints.end(); ++_iter232)
      {
        xfer += (*_iter232).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneObject &a, MSceneObject &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Name, b.Name);
  swap(a.Transform, b.Transform);
  swap(a.Collider, b.Collider);
  swap(a.Mesh, b.Mesh);
  swap(a.PhysicsProperties, b.PhysicsProperties);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.Constraints, b.Constraints);
  swap(a.__isset, b.__isset);
}

MSceneObject::MSceneObject(const MSceneObject& other233) {
  ID = other233.ID;
  Name = other233.Name;
  Transform = other233.Transform;
  Collider = other233.Collider;
  Mesh = other233.Mesh;
  PhysicsProperties = other233.PhysicsProperties;
  Properties = other233.Properties;
  Attachments = other233.Attachments;
  Constraints = other233.Constraints;
  __isset = other233.__isset;
}
MSceneObject& MSceneObject::operator=(const MSceneObject& other234) {
  ID = other234.ID;
  Name = other234.Name;
  Transform = other234.Transform;
  Collider = other234.Collider;
  Mesh = other234.Mesh;
  PhysicsProperties = other234.PhysicsProperties;
  Properties = other234.Properties;
  Attachments = other234.Attachments;
  Constraints = other234.Constraints;
  __isset = other234.__isset;
  return *this;
}
void MSceneObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneObject(";
  out << "ID=" << to_string(ID);
  out << ", " << "Name=" << to_string(Name);
  out << ", " << "Transform=" << to_string(Transform);
  out << ", " << "Collider="; (__isset.Collider ? (out << to_string(Collider)) : (out << "<null>"));
  out << ", " << "Mesh="; (__isset.Mesh ? (out << to_string(Mesh)) : (out << "<null>"));
  out << ", " << "PhysicsProperties="; (__isset.PhysicsProperties ? (out << to_string(PhysicsProperties)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ")";
}


MSceneObjectUpdate::~MSceneObjectUpdate() noexcept {
}


void MSceneObjectUpdate::__set_ID(const std::string& val) {
  this->ID = val;
}

void MSceneObjectUpdate::__set_Name(const std::string& val) {
  this->Name = val;
__isset.Name = true;
}

void MSceneObjectUpdate::__set_Transform(const MTransformUpdate& val) {
  this->Transform = val;
__isset.Transform = true;
}

void MSceneObjectUpdate::__set_Collider(const MCollider& val) {
  this->Collider = val;
__isset.Collider = true;
}

void MSceneObjectUpdate::__set_Mesh(const MMesh& val) {
  this->Mesh = val;
__isset.Mesh = true;
}

void MSceneObjectUpdate::__set_PhysicsProperties(const MPhysicsProperties& val) {
  this->PhysicsProperties = val;
__isset.PhysicsProperties = true;
}

void MSceneObjectUpdate::__set_HandPoses(const std::vector< ::MMIStandard::MHandPose> & val) {
  this->HandPoses = val;
__isset.HandPoses = true;
}

void MSceneObjectUpdate::__set_Properties(const std::vector<MPropertyUpdate> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MSceneObjectUpdate::__set_Attachments(const std::vector<MAttachment> & val) {
  this->Attachments = val;
__isset.Attachments = true;
}

void MSceneObjectUpdate::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneObjectUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneObjectUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          this->__isset.Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Transform.read(iprot);
          this->__isset.Transform = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Collider.read(iprot);
          this->__isset.Collider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Mesh.read(iprot);
          this->__isset.Mesh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PhysicsProperties.read(iprot);
          this->__isset.PhysicsProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->HandPoses.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readListBegin(_etype238, _size235);
            this->HandPoses.resize(_size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              xfer += this->HandPoses[_i239].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.HandPoses = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size240;
            ::apache::thrift::protocol::TType _etype243;
            xfer += iprot->readListBegin(_etype243, _size240);
            this->Properties.resize(_size240);
            uint32_t _i244;
            for (_i244 = 0; _i244 < _size240; ++_i244)
            {
              xfer += this->Properties[_i244].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Attachments.clear();
            uint32_t _size245;
            ::apache::thrift::protocol::TType _etype248;
            xfer += iprot->readListBegin(_etype248, _size245);
            this->Attachments.resize(_size245);
            uint32_t _i249;
            for (_i249 = 0; _i249 < _size245; ++_i249)
            {
              xfer += this->Attachments[_i249].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Attachments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _etype253;
            xfer += iprot->readListBegin(_etype253, _size250);
            this->Constraints.resize(_size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              xfer += this->Constraints[_i254].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSceneObjectUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneObjectUpdate");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Name) {
    xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->Name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Transform) {
    xfer += oprot->writeFieldBegin("Transform", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->Transform.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Collider) {
    xfer += oprot->writeFieldBegin("Collider", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Collider.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Mesh) {
    xfer += oprot->writeFieldBegin("Mesh", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->Mesh.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.PhysicsProperties) {
    xfer += oprot->writeFieldBegin("PhysicsProperties", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->PhysicsProperties.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.HandPoses) {
    xfer += oprot->writeFieldBegin("HandPoses", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->HandPoses.size()));
      std::vector< ::MMIStandard::MHandPose> ::const_iterator _iter255;
      for (_iter255 = this->HandPoses.begin(); _iter255 != this->HandPoses.end(); ++_iter255)
      {
        xfer += (*_iter255).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyUpdate> ::const_iterator _iter256;
      for (_iter256 = this->Properties.begin(); _iter256 != this->Properties.end(); ++_iter256)
      {
        xfer += (*_iter256).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Attachments) {
    xfer += oprot->writeFieldBegin("Attachments", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Attachments.size()));
      std::vector<MAttachment> ::const_iterator _iter257;
      for (_iter257 = this->Attachments.begin(); _iter257 != this->Attachments.end(); ++_iter257)
      {
        xfer += (*_iter257).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter258;
      for (_iter258 = this->Constraints.begin(); _iter258 != this->Constraints.end(); ++_iter258)
      {
        xfer += (*_iter258).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneObjectUpdate &a, MSceneObjectUpdate &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Name, b.Name);
  swap(a.Transform, b.Transform);
  swap(a.Collider, b.Collider);
  swap(a.Mesh, b.Mesh);
  swap(a.PhysicsProperties, b.PhysicsProperties);
  swap(a.HandPoses, b.HandPoses);
  swap(a.Properties, b.Properties);
  swap(a.Attachments, b.Attachments);
  swap(a.Constraints, b.Constraints);
  swap(a.__isset, b.__isset);
}

MSceneObjectUpdate::MSceneObjectUpdate(const MSceneObjectUpdate& other259) {
  ID = other259.ID;
  Name = other259.Name;
  Transform = other259.Transform;
  Collider = other259.Collider;
  Mesh = other259.Mesh;
  PhysicsProperties = other259.PhysicsProperties;
  HandPoses = other259.HandPoses;
  Properties = other259.Properties;
  Attachments = other259.Attachments;
  Constraints = other259.Constraints;
  __isset = other259.__isset;
}
MSceneObjectUpdate& MSceneObjectUpdate::operator=(const MSceneObjectUpdate& other260) {
  ID = other260.ID;
  Name = other260.Name;
  Transform = other260.Transform;
  Collider = other260.Collider;
  Mesh = other260.Mesh;
  PhysicsProperties = other260.PhysicsProperties;
  HandPoses = other260.HandPoses;
  Properties = other260.Properties;
  Attachments = other260.Attachments;
  Constraints = other260.Constraints;
  __isset = other260.__isset;
  return *this;
}
void MSceneObjectUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneObjectUpdate(";
  out << "ID=" << to_string(ID);
  out << ", " << "Name="; (__isset.Name ? (out << to_string(Name)) : (out << "<null>"));
  out << ", " << "Transform="; (__isset.Transform ? (out << to_string(Transform)) : (out << "<null>"));
  out << ", " << "Collider="; (__isset.Collider ? (out << to_string(Collider)) : (out << "<null>"));
  out << ", " << "Mesh="; (__isset.Mesh ? (out << to_string(Mesh)) : (out << "<null>"));
  out << ", " << "PhysicsProperties="; (__isset.PhysicsProperties ? (out << to_string(PhysicsProperties)) : (out << "<null>"));
  out << ", " << "HandPoses="; (__isset.HandPoses ? (out << to_string(HandPoses)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Attachments="; (__isset.Attachments ? (out << to_string(Attachments)) : (out << "<null>"));
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ")";
}


MSceneUpdate::~MSceneUpdate() noexcept {
}


void MSceneUpdate::__set_AddedSceneObjects(const std::vector<MSceneObject> & val) {
  this->AddedSceneObjects = val;
__isset.AddedSceneObjects = true;
}

void MSceneUpdate::__set_ChangedSceneObjects(const std::vector<MSceneObjectUpdate> & val) {
  this->ChangedSceneObjects = val;
__isset.ChangedSceneObjects = true;
}

void MSceneUpdate::__set_RemovedSceneObjects(const std::vector<std::string> & val) {
  this->RemovedSceneObjects = val;
__isset.RemovedSceneObjects = true;
}

void MSceneUpdate::__set_AddedAvatars(const std::vector< ::MMIStandard::MAvatar> & val) {
  this->AddedAvatars = val;
__isset.AddedAvatars = true;
}

void MSceneUpdate::__set_ChangedAvatars(const std::vector<MAvatarUpdate> & val) {
  this->ChangedAvatars = val;
__isset.ChangedAvatars = true;
}

void MSceneUpdate::__set_RemovedAvatars(const std::vector<std::string> & val) {
  this->RemovedAvatars = val;
__isset.RemovedAvatars = true;
}
std::ostream& operator<<(std::ostream& out, const MSceneUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSceneUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AddedSceneObjects.clear();
            uint32_t _size261;
            ::apache::thrift::protocol::TType _etype264;
            xfer += iprot->readListBegin(_etype264, _size261);
            this->AddedSceneObjects.resize(_size261);
            uint32_t _i265;
            for (_i265 = 0; _i265 < _size261; ++_i265)
            {
              xfer += this->AddedSceneObjects[_i265].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AddedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ChangedSceneObjects.clear();
            uint32_t _size266;
            ::apache::thrift::protocol::TType _etype269;
            xfer += iprot->readListBegin(_etype269, _size266);
            this->ChangedSceneObjects.resize(_size266);
            uint32_t _i270;
            for (_i270 = 0; _i270 < _size266; ++_i270)
            {
              xfer += this->ChangedSceneObjects[_i270].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ChangedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RemovedSceneObjects.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->RemovedSceneObjects.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += iprot->readString(this->RemovedSceneObjects[_i275]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.RemovedSceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->AddedAvatars.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->AddedAvatars.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->AddedAvatars[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.AddedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ChangedAvatars.clear();
            uint32_t _size281;
            ::apache::thrift::protocol::TType _etype284;
            xfer += iprot->readListBegin(_etype284, _size281);
            this->ChangedAvatars.resize(_size281);
            uint32_t _i285;
            for (_i285 = 0; _i285 < _size281; ++_i285)
            {
              xfer += this->ChangedAvatars[_i285].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ChangedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->RemovedAvatars.clear();
            uint32_t _size286;
            ::apache::thrift::protocol::TType _etype289;
            xfer += iprot->readListBegin(_etype289, _size286);
            this->RemovedAvatars.resize(_size286);
            uint32_t _i290;
            for (_i290 = 0; _i290 < _size286; ++_i290)
            {
              xfer += iprot->readString(this->RemovedAvatars[_i290]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.RemovedAvatars = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MSceneUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSceneUpdate");

  if (this->__isset.AddedSceneObjects) {
    xfer += oprot->writeFieldBegin("AddedSceneObjects", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->AddedSceneObjects.size()));
      std::vector<MSceneObject> ::const_iterator _iter291;
      for (_iter291 = this->AddedSceneObjects.begin(); _iter291 != this->AddedSceneObjects.end(); ++_iter291)
      {
        xfer += (*_iter291).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ChangedSceneObjects) {
    xfer += oprot->writeFieldBegin("ChangedSceneObjects", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ChangedSceneObjects.size()));
      std::vector<MSceneObjectUpdate> ::const_iterator _iter292;
      for (_iter292 = this->ChangedSceneObjects.begin(); _iter292 != this->ChangedSceneObjects.end(); ++_iter292)
      {
        xfer += (*_iter292).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RemovedSceneObjects) {
    xfer += oprot->writeFieldBegin("RemovedSceneObjects", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RemovedSceneObjects.size()));
      std::vector<std::string> ::const_iterator _iter293;
      for (_iter293 = this->RemovedSceneObjects.begin(); _iter293 != this->RemovedSceneObjects.end(); ++_iter293)
      {
        xfer += oprot->writeString((*_iter293));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.AddedAvatars) {
    xfer += oprot->writeFieldBegin("AddedAvatars", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->AddedAvatars.size()));
      std::vector< ::MMIStandard::MAvatar> ::const_iterator _iter294;
      for (_iter294 = this->AddedAvatars.begin(); _iter294 != this->AddedAvatars.end(); ++_iter294)
      {
        xfer += (*_iter294).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ChangedAvatars) {
    xfer += oprot->writeFieldBegin("ChangedAvatars", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ChangedAvatars.size()));
      std::vector<MAvatarUpdate> ::const_iterator _iter295;
      for (_iter295 = this->ChangedAvatars.begin(); _iter295 != this->ChangedAvatars.end(); ++_iter295)
      {
        xfer += (*_iter295).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.RemovedAvatars) {
    xfer += oprot->writeFieldBegin("RemovedAvatars", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->RemovedAvatars.size()));
      std::vector<std::string> ::const_iterator _iter296;
      for (_iter296 = this->RemovedAvatars.begin(); _iter296 != this->RemovedAvatars.end(); ++_iter296)
      {
        xfer += oprot->writeString((*_iter296));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSceneUpdate &a, MSceneUpdate &b) {
  using ::std::swap;
  swap(a.AddedSceneObjects, b.AddedSceneObjects);
  swap(a.ChangedSceneObjects, b.ChangedSceneObjects);
  swap(a.RemovedSceneObjects, b.RemovedSceneObjects);
  swap(a.AddedAvatars, b.AddedAvatars);
  swap(a.ChangedAvatars, b.ChangedAvatars);
  swap(a.RemovedAvatars, b.RemovedAvatars);
  swap(a.__isset, b.__isset);
}

MSceneUpdate::MSceneUpdate(const MSceneUpdate& other297) {
  AddedSceneObjects = other297.AddedSceneObjects;
  ChangedSceneObjects = other297.ChangedSceneObjects;
  RemovedSceneObjects = other297.RemovedSceneObjects;
  AddedAvatars = other297.AddedAvatars;
  ChangedAvatars = other297.ChangedAvatars;
  RemovedAvatars = other297.RemovedAvatars;
  __isset = other297.__isset;
}
MSceneUpdate& MSceneUpdate::operator=(const MSceneUpdate& other298) {
  AddedSceneObjects = other298.AddedSceneObjects;
  ChangedSceneObjects = other298.ChangedSceneObjects;
  RemovedSceneObjects = other298.RemovedSceneObjects;
  AddedAvatars = other298.AddedAvatars;
  ChangedAvatars = other298.ChangedAvatars;
  RemovedAvatars = other298.RemovedAvatars;
  __isset = other298.__isset;
  return *this;
}
void MSceneUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSceneUpdate(";
  out << "AddedSceneObjects="; (__isset.AddedSceneObjects ? (out << to_string(AddedSceneObjects)) : (out << "<null>"));
  out << ", " << "ChangedSceneObjects="; (__isset.ChangedSceneObjects ? (out << to_string(ChangedSceneObjects)) : (out << "<null>"));
  out << ", " << "RemovedSceneObjects="; (__isset.RemovedSceneObjects ? (out << to_string(RemovedSceneObjects)) : (out << "<null>"));
  out << ", " << "AddedAvatars="; (__isset.AddedAvatars ? (out << to_string(AddedAvatars)) : (out << "<null>"));
  out << ", " << "ChangedAvatars="; (__isset.ChangedAvatars ? (out << to_string(ChangedAvatars)) : (out << "<null>"));
  out << ", " << "RemovedAvatars="; (__isset.RemovedAvatars ? (out << to_string(RemovedAvatars)) : (out << "<null>"));
  out << ")";
}


MAvatarUpdate::~MAvatarUpdate() noexcept {
}


void MAvatarUpdate::__set_ID(const std::string& val) {
  this->ID = val;
}

void MAvatarUpdate::__set_PostureValues(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->PostureValues = val;
__isset.PostureValues = true;
}

void MAvatarUpdate::__set_SceneObjects(const std::vector<std::string> & val) {
  this->SceneObjects = val;
__isset.SceneObjects = true;
}

void MAvatarUpdate::__set_Description(const  ::MMIStandard::MAvatarDescription& val) {
  this->Description = val;
__isset.Description = true;
}

void MAvatarUpdate::__set_Properties(const std::vector<MPropertyUpdate> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MAvatarUpdate& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAvatarUpdate::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->PostureValues.read(iprot);
          this->__isset.PostureValues = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->SceneObjects.clear();
            uint32_t _size299;
            ::apache::thrift::protocol::TType _etype302;
            xfer += iprot->readListBegin(_etype302, _size299);
            this->SceneObjects.resize(_size299);
            uint32_t _i303;
            for (_i303 = 0; _i303 < _size299; ++_i303)
            {
              xfer += iprot->readString(this->SceneObjects[_i303]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.SceneObjects = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Description.read(iprot);
          this->__isset.Description = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Properties.clear();
            uint32_t _size304;
            ::apache::thrift::protocol::TType _etype307;
            xfer += iprot->readListBegin(_etype307, _size304);
            this->Properties.resize(_size304);
            uint32_t _i308;
            for (_i308 = 0; _i308 < _size304; ++_i308)
            {
              xfer += this->Properties[_i308].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MAvatarUpdate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAvatarUpdate");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.PostureValues) {
    xfer += oprot->writeFieldBegin("PostureValues", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->PostureValues.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SceneObjects) {
    xfer += oprot->writeFieldBegin("SceneObjects", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->SceneObjects.size()));
      std::vector<std::string> ::const_iterator _iter309;
      for (_iter309 = this->SceneObjects.begin(); _iter309 != this->SceneObjects.end(); ++_iter309)
      {
        xfer += oprot->writeString((*_iter309));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Description) {
    xfer += oprot->writeFieldBegin("Description", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->Description.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Properties.size()));
      std::vector<MPropertyUpdate> ::const_iterator _iter310;
      for (_iter310 = this->Properties.begin(); _iter310 != this->Properties.end(); ++_iter310)
      {
        xfer += (*_iter310).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAvatarUpdate &a, MAvatarUpdate &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.PostureValues, b.PostureValues);
  swap(a.SceneObjects, b.SceneObjects);
  swap(a.Description, b.Description);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MAvatarUpdate::MAvatarUpdate(const MAvatarUpdate& other311) {
  ID = other311.ID;
  PostureValues = other311.PostureValues;
  SceneObjects = other311.SceneObjects;
  Description = other311.Description;
  Properties = other311.Properties;
  __isset = other311.__isset;
}
MAvatarUpdate& MAvatarUpdate::operator=(const MAvatarUpdate& other312) {
  ID = other312.ID;
  PostureValues = other312.PostureValues;
  SceneObjects = other312.SceneObjects;
  Description = other312.Description;
  Properties = other312.Properties;
  __isset = other312.__isset;
  return *this;
}
void MAvatarUpdate::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAvatarUpdate(";
  out << "ID=" << to_string(ID);
  out << ", " << "PostureValues="; (__isset.PostureValues ? (out << to_string(PostureValues)) : (out << "<null>"));
  out << ", " << "SceneObjects="; (__isset.SceneObjects ? (out << to_string(SceneObjects)) : (out << "<null>"));
  out << ", " << "Description="; (__isset.Description ? (out << to_string(Description)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}

} // namespace
