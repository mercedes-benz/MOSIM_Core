/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mmu_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace MMIStandard {

int _kMCoordinateSystemTypeValues[] = {
  MCoordinateSystemType::Global,
  MCoordinateSystemType::Local
};
const char* _kMCoordinateSystemTypeNames[] = {
  "Global",
  "Local"
};
const std::map<int, const char*> _MCoordinateSystemType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kMCoordinateSystemTypeValues, _kMCoordinateSystemTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MCoordinateSystemType::type& val) {
  std::map<int, const char*>::const_iterator it = _MCoordinateSystemType_VALUES_TO_NAMES.find(val);
  if (it != _MCoordinateSystemType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MCoordinateSystemType::type& val) {
  std::map<int, const char*>::const_iterator it = _MCoordinateSystemType_VALUES_TO_NAMES.find(val);
  if (it != _MCoordinateSystemType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kMDependencyTypeValues[] = {
  MDependencyType::Service,
  MDependencyType::MMU,
  MDependencyType::ProgramLibrary,
  MDependencyType::MMIFramework,
  MDependencyType::Other
};
const char* _kMDependencyTypeNames[] = {
  "Service",
  "MMU",
  "ProgramLibrary",
  "MMIFramework",
  "Other"
};
const std::map<int, const char*> _MDependencyType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kMDependencyTypeValues, _kMDependencyTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const MDependencyType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDependencyType_VALUES_TO_NAMES.find(val);
  if (it != _MDependencyType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const MDependencyType::type& val) {
  std::map<int, const char*>::const_iterator it = _MDependencyType_VALUES_TO_NAMES.find(val);
  if (it != _MDependencyType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


MSimulationState::~MSimulationState() noexcept {
}


void MSimulationState::__set_Initial(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->Initial = val;
}

void MSimulationState::__set_Current(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->Current = val;
}

void MSimulationState::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}

void MSimulationState::__set_SceneManipulations(const std::vector< ::MMIStandard::MSceneManipulation> & val) {
  this->SceneManipulations = val;
__isset.SceneManipulations = true;
}

void MSimulationState::__set_Events(const std::vector<MSimulationEvent> & val) {
  this->Events = val;
__isset.Events = true;
}
std::ostream& operator<<(std::ostream& out, const MSimulationState& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSimulationState::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Initial = false;
  bool isset_Current = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Initial.read(iprot);
          isset_Initial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Current.read(iprot);
          isset_Current = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->Constraints.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += this->Constraints[_i4].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->SceneManipulations.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->SceneManipulations.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += this->SceneManipulations[_i9].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.SceneManipulations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Events.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->Events.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->Events[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Initial)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Current)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSimulationState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSimulationState");

  xfer += oprot->writeFieldBegin("Initial", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Initial.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Current", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->Current.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter15;
      for (_iter15 = this->Constraints.begin(); _iter15 != this->Constraints.end(); ++_iter15)
      {
        xfer += (*_iter15).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SceneManipulations) {
    xfer += oprot->writeFieldBegin("SceneManipulations", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->SceneManipulations.size()));
      std::vector< ::MMIStandard::MSceneManipulation> ::const_iterator _iter16;
      for (_iter16 = this->SceneManipulations.begin(); _iter16 != this->SceneManipulations.end(); ++_iter16)
      {
        xfer += (*_iter16).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Events) {
    xfer += oprot->writeFieldBegin("Events", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Events.size()));
      std::vector<MSimulationEvent> ::const_iterator _iter17;
      for (_iter17 = this->Events.begin(); _iter17 != this->Events.end(); ++_iter17)
      {
        xfer += (*_iter17).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSimulationState &a, MSimulationState &b) {
  using ::std::swap;
  swap(a.Initial, b.Initial);
  swap(a.Current, b.Current);
  swap(a.Constraints, b.Constraints);
  swap(a.SceneManipulations, b.SceneManipulations);
  swap(a.Events, b.Events);
  swap(a.__isset, b.__isset);
}

MSimulationState::MSimulationState(const MSimulationState& other18) {
  Initial = other18.Initial;
  Current = other18.Current;
  Constraints = other18.Constraints;
  SceneManipulations = other18.SceneManipulations;
  Events = other18.Events;
  __isset = other18.__isset;
}
MSimulationState& MSimulationState::operator=(const MSimulationState& other19) {
  Initial = other19.Initial;
  Current = other19.Current;
  Constraints = other19.Constraints;
  SceneManipulations = other19.SceneManipulations;
  Events = other19.Events;
  __isset = other19.__isset;
  return *this;
}
void MSimulationState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSimulationState(";
  out << "Initial=" << to_string(Initial);
  out << ", " << "Current=" << to_string(Current);
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ", " << "SceneManipulations="; (__isset.SceneManipulations ? (out << to_string(SceneManipulations)) : (out << "<null>"));
  out << ", " << "Events="; (__isset.Events ? (out << to_string(Events)) : (out << "<null>"));
  out << ")";
}


MSimulationResult::~MSimulationResult() noexcept {
}


void MSimulationResult::__set_Posture(const  ::MMIStandard::MAvatarPostureValues& val) {
  this->Posture = val;
}

void MSimulationResult::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}

void MSimulationResult::__set_Events(const std::vector<MSimulationEvent> & val) {
  this->Events = val;
__isset.Events = true;
}

void MSimulationResult::__set_SceneManipulations(const std::vector< ::MMIStandard::MSceneManipulation> & val) {
  this->SceneManipulations = val;
__isset.SceneManipulations = true;
}

void MSimulationResult::__set_DrawingCalls(const std::vector< ::MMIStandard::MDrawingCall> & val) {
  this->DrawingCalls = val;
__isset.DrawingCalls = true;
}

void MSimulationResult::__set_LogData(const std::vector<std::string> & val) {
  this->LogData = val;
__isset.LogData = true;
}
std::ostream& operator<<(std::ostream& out, const MSimulationResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSimulationResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Posture = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->Posture.read(iprot);
          isset_Posture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->Constraints.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->Constraints[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Events.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->Events.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->Events[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->SceneManipulations.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->SceneManipulations.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->SceneManipulations[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.SceneManipulations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->DrawingCalls.clear();
            uint32_t _size35;
            ::apache::thrift::protocol::TType _etype38;
            xfer += iprot->readListBegin(_etype38, _size35);
            this->DrawingCalls.resize(_size35);
            uint32_t _i39;
            for (_i39 = 0; _i39 < _size35; ++_i39)
            {
              xfer += this->DrawingCalls[_i39].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.DrawingCalls = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->LogData.clear();
            uint32_t _size40;
            ::apache::thrift::protocol::TType _etype43;
            xfer += iprot->readListBegin(_etype43, _size40);
            this->LogData.resize(_size40);
            uint32_t _i44;
            for (_i44 = 0; _i44 < _size40; ++_i44)
            {
              xfer += iprot->readString(this->LogData[_i44]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.LogData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Posture)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSimulationResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSimulationResult");

  xfer += oprot->writeFieldBegin("Posture", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->Posture.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter45;
      for (_iter45 = this->Constraints.begin(); _iter45 != this->Constraints.end(); ++_iter45)
      {
        xfer += (*_iter45).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Events) {
    xfer += oprot->writeFieldBegin("Events", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Events.size()));
      std::vector<MSimulationEvent> ::const_iterator _iter46;
      for (_iter46 = this->Events.begin(); _iter46 != this->Events.end(); ++_iter46)
      {
        xfer += (*_iter46).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SceneManipulations) {
    xfer += oprot->writeFieldBegin("SceneManipulations", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->SceneManipulations.size()));
      std::vector< ::MMIStandard::MSceneManipulation> ::const_iterator _iter47;
      for (_iter47 = this->SceneManipulations.begin(); _iter47 != this->SceneManipulations.end(); ++_iter47)
      {
        xfer += (*_iter47).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.DrawingCalls) {
    xfer += oprot->writeFieldBegin("DrawingCalls", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->DrawingCalls.size()));
      std::vector< ::MMIStandard::MDrawingCall> ::const_iterator _iter48;
      for (_iter48 = this->DrawingCalls.begin(); _iter48 != this->DrawingCalls.end(); ++_iter48)
      {
        xfer += (*_iter48).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.LogData) {
    xfer += oprot->writeFieldBegin("LogData", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->LogData.size()));
      std::vector<std::string> ::const_iterator _iter49;
      for (_iter49 = this->LogData.begin(); _iter49 != this->LogData.end(); ++_iter49)
      {
        xfer += oprot->writeString((*_iter49));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSimulationResult &a, MSimulationResult &b) {
  using ::std::swap;
  swap(a.Posture, b.Posture);
  swap(a.Constraints, b.Constraints);
  swap(a.Events, b.Events);
  swap(a.SceneManipulations, b.SceneManipulations);
  swap(a.DrawingCalls, b.DrawingCalls);
  swap(a.LogData, b.LogData);
  swap(a.__isset, b.__isset);
}

MSimulationResult::MSimulationResult(const MSimulationResult& other50) {
  Posture = other50.Posture;
  Constraints = other50.Constraints;
  Events = other50.Events;
  SceneManipulations = other50.SceneManipulations;
  DrawingCalls = other50.DrawingCalls;
  LogData = other50.LogData;
  __isset = other50.__isset;
}
MSimulationResult& MSimulationResult::operator=(const MSimulationResult& other51) {
  Posture = other51.Posture;
  Constraints = other51.Constraints;
  Events = other51.Events;
  SceneManipulations = other51.SceneManipulations;
  DrawingCalls = other51.DrawingCalls;
  LogData = other51.LogData;
  __isset = other51.__isset;
  return *this;
}
void MSimulationResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSimulationResult(";
  out << "Posture=" << to_string(Posture);
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ", " << "Events="; (__isset.Events ? (out << to_string(Events)) : (out << "<null>"));
  out << ", " << "SceneManipulations="; (__isset.SceneManipulations ? (out << to_string(SceneManipulations)) : (out << "<null>"));
  out << ", " << "DrawingCalls="; (__isset.DrawingCalls ? (out << to_string(DrawingCalls)) : (out << "<null>"));
  out << ", " << "LogData="; (__isset.LogData ? (out << to_string(LogData)) : (out << "<null>"));
  out << ")";
}


MSimulationEvent::~MSimulationEvent() noexcept {
}


void MSimulationEvent::__set_Name(const std::string& val) {
  this->Name = val;
}

void MSimulationEvent::__set_Type(const std::string& val) {
  this->Type = val;
}

void MSimulationEvent::__set_Reference(const std::string& val) {
  this->Reference = val;
}

void MSimulationEvent::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}
std::ostream& operator<<(std::ostream& out, const MSimulationEvent& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MSimulationEvent::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Name = false;
  bool isset_Type = false;
  bool isset_Reference = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          isset_Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Type);
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Reference);
          isset_Reference = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _ktype53;
            ::apache::thrift::protocol::TType _vtype54;
            xfer += iprot->readMapBegin(_ktype53, _vtype54, _size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              std::string _key57;
              xfer += iprot->readString(_key57);
              std::string& _val58 = this->Properties[_key57];
              xfer += iprot->readString(_val58);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Reference)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MSimulationEvent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MSimulationEvent");

  xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Reference", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->Reference);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter59;
      for (_iter59 = this->Properties.begin(); _iter59 != this->Properties.end(); ++_iter59)
      {
        xfer += oprot->writeString(_iter59->first);
        xfer += oprot->writeString(_iter59->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MSimulationEvent &a, MSimulationEvent &b) {
  using ::std::swap;
  swap(a.Name, b.Name);
  swap(a.Type, b.Type);
  swap(a.Reference, b.Reference);
  swap(a.Properties, b.Properties);
  swap(a.__isset, b.__isset);
}

MSimulationEvent::MSimulationEvent(const MSimulationEvent& other60) {
  Name = other60.Name;
  Type = other60.Type;
  Reference = other60.Reference;
  Properties = other60.Properties;
  __isset = other60.__isset;
}
MSimulationEvent& MSimulationEvent::operator=(const MSimulationEvent& other61) {
  Name = other61.Name;
  Type = other61.Type;
  Reference = other61.Reference;
  Properties = other61.Properties;
  __isset = other61.__isset;
  return *this;
}
void MSimulationEvent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MSimulationEvent(";
  out << "Name=" << to_string(Name);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "Reference=" << to_string(Reference);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ")";
}


MVersion::~MVersion() noexcept {
}


void MVersion::__set_Major(const int16_t val) {
  this->Major = val;
}

void MVersion::__set_Minor(const int16_t val) {
  this->Minor = val;
__isset.Minor = true;
}

void MVersion::__set_Sub(const int16_t val) {
  this->Sub = val;
__isset.Sub = true;
}

void MVersion::__set_Subsub(const int16_t val) {
  this->Subsub = val;
__isset.Subsub = true;
}
std::ostream& operator<<(std::ostream& out, const MVersion& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MVersion::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Major = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->Major);
          isset_Major = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->Minor);
          this->__isset.Minor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->Sub);
          this->__isset.Sub = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->Subsub);
          this->__isset.Subsub = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Major)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MVersion::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MVersion");

  xfer += oprot->writeFieldBegin("Major", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->Major);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Minor) {
    xfer += oprot->writeFieldBegin("Minor", ::apache::thrift::protocol::T_I16, 2);
    xfer += oprot->writeI16(this->Minor);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Sub) {
    xfer += oprot->writeFieldBegin("Sub", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->Sub);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Subsub) {
    xfer += oprot->writeFieldBegin("Subsub", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->Subsub);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MVersion &a, MVersion &b) {
  using ::std::swap;
  swap(a.Major, b.Major);
  swap(a.Minor, b.Minor);
  swap(a.Sub, b.Sub);
  swap(a.Subsub, b.Subsub);
  swap(a.__isset, b.__isset);
}

MVersion::MVersion(const MVersion& other62) {
  Major = other62.Major;
  Minor = other62.Minor;
  Sub = other62.Sub;
  Subsub = other62.Subsub;
  __isset = other62.__isset;
}
MVersion& MVersion::operator=(const MVersion& other63) {
  Major = other63.Major;
  Minor = other63.Minor;
  Sub = other63.Sub;
  Subsub = other63.Subsub;
  __isset = other63.__isset;
  return *this;
}
void MVersion::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MVersion(";
  out << "Major=" << to_string(Major);
  out << ", " << "Minor="; (__isset.Minor ? (out << to_string(Minor)) : (out << "<null>"));
  out << ", " << "Sub="; (__isset.Sub ? (out << to_string(Sub)) : (out << "<null>"));
  out << ", " << "Subsub="; (__isset.Subsub ? (out << to_string(Subsub)) : (out << "<null>"));
  out << ")";
}


MDependency::~MDependency() noexcept {
}


void MDependency::__set_ID(const std::string& val) {
  this->ID = val;
}

void MDependency::__set_Type(const MDependencyType::type val) {
  this->Type = val;
}

void MDependency::__set_MinVersion(const MVersion& val) {
  this->MinVersion = val;
}

void MDependency::__set_MaxVersion(const MVersion& val) {
  this->MaxVersion = val;
}

void MDependency::__set_ExcludedVersions(const std::vector<MVersion> & val) {
  this->ExcludedVersions = val;
__isset.ExcludedVersions = true;
}

void MDependency::__set_Name(const std::string& val) {
  this->Name = val;
__isset.Name = true;
}
std::ostream& operator<<(std::ostream& out, const MDependency& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MDependency::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Type = false;
  bool isset_MinVersion = false;
  bool isset_MaxVersion = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          this->Type = (MDependencyType::type)ecast64;
          isset_Type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MinVersion.read(iprot);
          isset_MinVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->MaxVersion.read(iprot);
          isset_MaxVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ExcludedVersions.clear();
            uint32_t _size65;
            ::apache::thrift::protocol::TType _etype68;
            xfer += iprot->readListBegin(_etype68, _size65);
            this->ExcludedVersions.resize(_size65);
            uint32_t _i69;
            for (_i69 = 0; _i69 < _size65; ++_i69)
            {
              xfer += this->ExcludedVersions[_i69].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ExcludedVersions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          this->__isset.Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MinVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MaxVersion)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MDependency::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MDependency");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->Type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MinVersion", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->MinVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MaxVersion", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->MaxVersion.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ExcludedVersions) {
    xfer += oprot->writeFieldBegin("ExcludedVersions", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ExcludedVersions.size()));
      std::vector<MVersion> ::const_iterator _iter70;
      for (_iter70 = this->ExcludedVersions.begin(); _iter70 != this->ExcludedVersions.end(); ++_iter70)
      {
        xfer += (*_iter70).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Name) {
    xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->Name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MDependency &a, MDependency &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Type, b.Type);
  swap(a.MinVersion, b.MinVersion);
  swap(a.MaxVersion, b.MaxVersion);
  swap(a.ExcludedVersions, b.ExcludedVersions);
  swap(a.Name, b.Name);
  swap(a.__isset, b.__isset);
}

MDependency::MDependency(const MDependency& other71) {
  ID = other71.ID;
  Type = other71.Type;
  MinVersion = other71.MinVersion;
  MaxVersion = other71.MaxVersion;
  ExcludedVersions = other71.ExcludedVersions;
  Name = other71.Name;
  __isset = other71.__isset;
}
MDependency& MDependency::operator=(const MDependency& other72) {
  ID = other72.ID;
  Type = other72.Type;
  MinVersion = other72.MinVersion;
  MaxVersion = other72.MaxVersion;
  ExcludedVersions = other72.ExcludedVersions;
  Name = other72.Name;
  __isset = other72.__isset;
  return *this;
}
void MDependency::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MDependency(";
  out << "ID=" << to_string(ID);
  out << ", " << "Type=" << to_string(Type);
  out << ", " << "MinVersion=" << to_string(MinVersion);
  out << ", " << "MaxVersion=" << to_string(MaxVersion);
  out << ", " << "ExcludedVersions="; (__isset.ExcludedVersions ? (out << to_string(ExcludedVersions)) : (out << "<null>"));
  out << ", " << "Name="; (__isset.Name ? (out << to_string(Name)) : (out << "<null>"));
  out << ")";
}


MMUDescription::~MMUDescription() noexcept {
}


void MMUDescription::__set_Name(const std::string& val) {
  this->Name = val;
}

void MMUDescription::__set_ID(const std::string& val) {
  this->ID = val;
}

void MMUDescription::__set_AssemblyName(const std::string& val) {
  this->AssemblyName = val;
}

void MMUDescription::__set_MotionType(const std::string& val) {
  this->MotionType = val;
}

void MMUDescription::__set_Language(const std::string& val) {
  this->Language = val;
}

void MMUDescription::__set_Author(const std::string& val) {
  this->Author = val;
}

void MMUDescription::__set_Version(const std::string& val) {
  this->Version = val;
}

void MMUDescription::__set_Prerequisites(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Prerequisites = val;
__isset.Prerequisites = true;
}

void MMUDescription::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MMUDescription::__set_Dependencies(const std::vector<MDependency> & val) {
  this->Dependencies = val;
__isset.Dependencies = true;
}

void MMUDescription::__set_Events(const std::vector<std::string> & val) {
  this->Events = val;
__isset.Events = true;
}

void MMUDescription::__set_LongDescription(const std::string& val) {
  this->LongDescription = val;
__isset.LongDescription = true;
}

void MMUDescription::__set_ShortDescription(const std::string& val) {
  this->ShortDescription = val;
__isset.ShortDescription = true;
}

void MMUDescription::__set_Parameters(const std::vector< ::MMIStandard::MParameter> & val) {
  this->Parameters = val;
__isset.Parameters = true;
}

void MMUDescription::__set_SceneParameters(const std::vector< ::MMIStandard::MParameter> & val) {
  this->SceneParameters = val;
__isset.SceneParameters = true;
}
std::ostream& operator<<(std::ostream& out, const MMUDescription& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MMUDescription::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_Name = false;
  bool isset_ID = false;
  bool isset_AssemblyName = false;
  bool isset_MotionType = false;
  bool isset_Language = false;
  bool isset_Author = false;
  bool isset_Version = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          isset_Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->AssemblyName);
          isset_AssemblyName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->MotionType);
          isset_MotionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Language);
          isset_Language = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Author);
          isset_Author = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Version);
          isset_Version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Prerequisites.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _etype76;
            xfer += iprot->readListBegin(_etype76, _size73);
            this->Prerequisites.resize(_size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              xfer += this->Prerequisites[_i77].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Prerequisites = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size78;
            ::apache::thrift::protocol::TType _ktype79;
            ::apache::thrift::protocol::TType _vtype80;
            xfer += iprot->readMapBegin(_ktype79, _vtype80, _size78);
            uint32_t _i82;
            for (_i82 = 0; _i82 < _size78; ++_i82)
            {
              std::string _key83;
              xfer += iprot->readString(_key83);
              std::string& _val84 = this->Properties[_key83];
              xfer += iprot->readString(_val84);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Dependencies.clear();
            uint32_t _size85;
            ::apache::thrift::protocol::TType _etype88;
            xfer += iprot->readListBegin(_etype88, _size85);
            this->Dependencies.resize(_size85);
            uint32_t _i89;
            for (_i89 = 0; _i89 < _size85; ++_i89)
            {
              xfer += this->Dependencies[_i89].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Dependencies = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Events.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->Events.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += iprot->readString(this->Events[_i94]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Events = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->LongDescription);
          this->__isset.LongDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ShortDescription);
          this->__isset.ShortDescription = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Parameters.clear();
            uint32_t _size95;
            ::apache::thrift::protocol::TType _etype98;
            xfer += iprot->readListBegin(_etype98, _size95);
            this->Parameters.resize(_size95);
            uint32_t _i99;
            for (_i99 = 0; _i99 < _size95; ++_i99)
            {
              xfer += this->Parameters[_i99].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->SceneParameters.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->SceneParameters.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->SceneParameters[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.SceneParameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_Name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_AssemblyName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MotionType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Language)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Author)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Version)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MMUDescription::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MMUDescription");

  xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->Name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AssemblyName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->AssemblyName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MotionType", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->MotionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Language", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->Language);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Author", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->Author);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Version", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->Version);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Prerequisites) {
    xfer += oprot->writeFieldBegin("Prerequisites", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Prerequisites.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter105;
      for (_iter105 = this->Prerequisites.begin(); _iter105 != this->Prerequisites.end(); ++_iter105)
      {
        xfer += (*_iter105).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter106;
      for (_iter106 = this->Properties.begin(); _iter106 != this->Properties.end(); ++_iter106)
      {
        xfer += oprot->writeString(_iter106->first);
        xfer += oprot->writeString(_iter106->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Dependencies) {
    xfer += oprot->writeFieldBegin("Dependencies", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Dependencies.size()));
      std::vector<MDependency> ::const_iterator _iter107;
      for (_iter107 = this->Dependencies.begin(); _iter107 != this->Dependencies.end(); ++_iter107)
      {
        xfer += (*_iter107).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Events) {
    xfer += oprot->writeFieldBegin("Events", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Events.size()));
      std::vector<std::string> ::const_iterator _iter108;
      for (_iter108 = this->Events.begin(); _iter108 != this->Events.end(); ++_iter108)
      {
        xfer += oprot->writeString((*_iter108));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.LongDescription) {
    xfer += oprot->writeFieldBegin("LongDescription", ::apache::thrift::protocol::T_STRING, 14);
    xfer += oprot->writeString(this->LongDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ShortDescription) {
    xfer += oprot->writeFieldBegin("ShortDescription", ::apache::thrift::protocol::T_STRING, 15);
    xfer += oprot->writeString(this->ShortDescription);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Parameters) {
    xfer += oprot->writeFieldBegin("Parameters", ::apache::thrift::protocol::T_LIST, 16);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Parameters.size()));
      std::vector< ::MMIStandard::MParameter> ::const_iterator _iter109;
      for (_iter109 = this->Parameters.begin(); _iter109 != this->Parameters.end(); ++_iter109)
      {
        xfer += (*_iter109).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.SceneParameters) {
    xfer += oprot->writeFieldBegin("SceneParameters", ::apache::thrift::protocol::T_LIST, 17);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->SceneParameters.size()));
      std::vector< ::MMIStandard::MParameter> ::const_iterator _iter110;
      for (_iter110 = this->SceneParameters.begin(); _iter110 != this->SceneParameters.end(); ++_iter110)
      {
        xfer += (*_iter110).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MMUDescription &a, MMUDescription &b) {
  using ::std::swap;
  swap(a.Name, b.Name);
  swap(a.ID, b.ID);
  swap(a.AssemblyName, b.AssemblyName);
  swap(a.MotionType, b.MotionType);
  swap(a.Language, b.Language);
  swap(a.Author, b.Author);
  swap(a.Version, b.Version);
  swap(a.Prerequisites, b.Prerequisites);
  swap(a.Properties, b.Properties);
  swap(a.Dependencies, b.Dependencies);
  swap(a.Events, b.Events);
  swap(a.LongDescription, b.LongDescription);
  swap(a.ShortDescription, b.ShortDescription);
  swap(a.Parameters, b.Parameters);
  swap(a.SceneParameters, b.SceneParameters);
  swap(a.__isset, b.__isset);
}

MMUDescription::MMUDescription(const MMUDescription& other111) {
  Name = other111.Name;
  ID = other111.ID;
  AssemblyName = other111.AssemblyName;
  MotionType = other111.MotionType;
  Language = other111.Language;
  Author = other111.Author;
  Version = other111.Version;
  Prerequisites = other111.Prerequisites;
  Properties = other111.Properties;
  Dependencies = other111.Dependencies;
  Events = other111.Events;
  LongDescription = other111.LongDescription;
  ShortDescription = other111.ShortDescription;
  Parameters = other111.Parameters;
  SceneParameters = other111.SceneParameters;
  __isset = other111.__isset;
}
MMUDescription& MMUDescription::operator=(const MMUDescription& other112) {
  Name = other112.Name;
  ID = other112.ID;
  AssemblyName = other112.AssemblyName;
  MotionType = other112.MotionType;
  Language = other112.Language;
  Author = other112.Author;
  Version = other112.Version;
  Prerequisites = other112.Prerequisites;
  Properties = other112.Properties;
  Dependencies = other112.Dependencies;
  Events = other112.Events;
  LongDescription = other112.LongDescription;
  ShortDescription = other112.ShortDescription;
  Parameters = other112.Parameters;
  SceneParameters = other112.SceneParameters;
  __isset = other112.__isset;
  return *this;
}
void MMUDescription::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MMUDescription(";
  out << "Name=" << to_string(Name);
  out << ", " << "ID=" << to_string(ID);
  out << ", " << "AssemblyName=" << to_string(AssemblyName);
  out << ", " << "MotionType=" << to_string(MotionType);
  out << ", " << "Language=" << to_string(Language);
  out << ", " << "Author=" << to_string(Author);
  out << ", " << "Version=" << to_string(Version);
  out << ", " << "Prerequisites="; (__isset.Prerequisites ? (out << to_string(Prerequisites)) : (out << "<null>"));
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Dependencies="; (__isset.Dependencies ? (out << to_string(Dependencies)) : (out << "<null>"));
  out << ", " << "Events="; (__isset.Events ? (out << to_string(Events)) : (out << "<null>"));
  out << ", " << "LongDescription="; (__isset.LongDescription ? (out << to_string(LongDescription)) : (out << "<null>"));
  out << ", " << "ShortDescription="; (__isset.ShortDescription ? (out << to_string(ShortDescription)) : (out << "<null>"));
  out << ", " << "Parameters="; (__isset.Parameters ? (out << to_string(Parameters)) : (out << "<null>"));
  out << ", " << "SceneParameters="; (__isset.SceneParameters ? (out << to_string(SceneParameters)) : (out << "<null>"));
  out << ")";
}


MInstruction::~MInstruction() noexcept {
}


void MInstruction::__set_ID(const std::string& val) {
  this->ID = val;
}

void MInstruction::__set_Name(const std::string& val) {
  this->Name = val;
}

void MInstruction::__set_MotionType(const std::string& val) {
  this->MotionType = val;
}

void MInstruction::__set_Properties(const std::map<std::string, std::string> & val) {
  this->Properties = val;
__isset.Properties = true;
}

void MInstruction::__set_Constraints(const std::vector< ::MMIStandard::MConstraint> & val) {
  this->Constraints = val;
__isset.Constraints = true;
}

void MInstruction::__set_StartCondition(const std::string& val) {
  this->StartCondition = val;
__isset.StartCondition = true;
}

void MInstruction::__set_EndCondition(const std::string& val) {
  this->EndCondition = val;
__isset.EndCondition = true;
}

void MInstruction::__set_Action(const std::string& val) {
  this->Action = val;
__isset.Action = true;
}

void MInstruction::__set_Instructions(const std::vector<MInstruction> & val) {
  this->Instructions = val;
__isset.Instructions = true;
}
std::ostream& operator<<(std::ostream& out, const MInstruction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MInstruction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_ID = false;
  bool isset_Name = false;
  bool isset_MotionType = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ID);
          isset_ID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Name);
          isset_Name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->MotionType);
          isset_MotionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->Properties.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _ktype114;
            ::apache::thrift::protocol::TType _vtype115;
            xfer += iprot->readMapBegin(_ktype114, _vtype115, _size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              std::string _key118;
              xfer += iprot->readString(_key118);
              std::string& _val119 = this->Properties[_key118];
              xfer += iprot->readString(_val119);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.Properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Constraints.clear();
            uint32_t _size120;
            ::apache::thrift::protocol::TType _etype123;
            xfer += iprot->readListBegin(_etype123, _size120);
            this->Constraints.resize(_size120);
            uint32_t _i124;
            for (_i124 = 0; _i124 < _size120; ++_i124)
            {
              xfer += this->Constraints[_i124].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->StartCondition);
          this->__isset.StartCondition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->EndCondition);
          this->__isset.EndCondition = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->Action);
          this->__isset.Action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->Instructions.clear();
            uint32_t _size125;
            ::apache::thrift::protocol::TType _etype128;
            xfer += iprot->readListBegin(_etype128, _size125);
            this->Instructions.resize(_size125);
            uint32_t _i129;
            for (_i129 = 0; _i129 < _size125; ++_i129)
            {
              xfer += this->Instructions[_i129].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.Instructions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_ID)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_Name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_MotionType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MInstruction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MInstruction");

  xfer += oprot->writeFieldBegin("ID", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("Name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->Name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("MotionType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->MotionType);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.Properties) {
    xfer += oprot->writeFieldBegin("Properties", ::apache::thrift::protocol::T_MAP, 4);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->Properties.size()));
      std::map<std::string, std::string> ::const_iterator _iter130;
      for (_iter130 = this->Properties.begin(); _iter130 != this->Properties.end(); ++_iter130)
      {
        xfer += oprot->writeString(_iter130->first);
        xfer += oprot->writeString(_iter130->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Constraints) {
    xfer += oprot->writeFieldBegin("Constraints", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Constraints.size()));
      std::vector< ::MMIStandard::MConstraint> ::const_iterator _iter131;
      for (_iter131 = this->Constraints.begin(); _iter131 != this->Constraints.end(); ++_iter131)
      {
        xfer += (*_iter131).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.StartCondition) {
    xfer += oprot->writeFieldBegin("StartCondition", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->StartCondition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.EndCondition) {
    xfer += oprot->writeFieldBegin("EndCondition", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->EndCondition);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Action) {
    xfer += oprot->writeFieldBegin("Action", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->Action);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.Instructions) {
    xfer += oprot->writeFieldBegin("Instructions", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->Instructions.size()));
      std::vector<MInstruction> ::const_iterator _iter132;
      for (_iter132 = this->Instructions.begin(); _iter132 != this->Instructions.end(); ++_iter132)
      {
        xfer += (*_iter132).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MInstruction &a, MInstruction &b) {
  using ::std::swap;
  swap(a.ID, b.ID);
  swap(a.Name, b.Name);
  swap(a.MotionType, b.MotionType);
  swap(a.Properties, b.Properties);
  swap(a.Constraints, b.Constraints);
  swap(a.StartCondition, b.StartCondition);
  swap(a.EndCondition, b.EndCondition);
  swap(a.Action, b.Action);
  swap(a.Instructions, b.Instructions);
  swap(a.__isset, b.__isset);
}

MInstruction::MInstruction(const MInstruction& other133) {
  ID = other133.ID;
  Name = other133.Name;
  MotionType = other133.MotionType;
  Properties = other133.Properties;
  Constraints = other133.Constraints;
  StartCondition = other133.StartCondition;
  EndCondition = other133.EndCondition;
  Action = other133.Action;
  Instructions = other133.Instructions;
  __isset = other133.__isset;
}
MInstruction& MInstruction::operator=(const MInstruction& other134) {
  ID = other134.ID;
  Name = other134.Name;
  MotionType = other134.MotionType;
  Properties = other134.Properties;
  Constraints = other134.Constraints;
  StartCondition = other134.StartCondition;
  EndCondition = other134.EndCondition;
  Action = other134.Action;
  Instructions = other134.Instructions;
  __isset = other134.__isset;
  return *this;
}
void MInstruction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MInstruction(";
  out << "ID=" << to_string(ID);
  out << ", " << "Name=" << to_string(Name);
  out << ", " << "MotionType=" << to_string(MotionType);
  out << ", " << "Properties="; (__isset.Properties ? (out << to_string(Properties)) : (out << "<null>"));
  out << ", " << "Constraints="; (__isset.Constraints ? (out << to_string(Constraints)) : (out << "<null>"));
  out << ", " << "StartCondition="; (__isset.StartCondition ? (out << to_string(StartCondition)) : (out << "<null>"));
  out << ", " << "EndCondition="; (__isset.EndCondition ? (out << to_string(EndCondition)) : (out << "<null>"));
  out << ", " << "Action="; (__isset.Action ? (out << to_string(Action)) : (out << "<null>"));
  out << ", " << "Instructions="; (__isset.Instructions ? (out << to_string(Instructions)) : (out << "<null>"));
  out << ")";
}

} // namespace
